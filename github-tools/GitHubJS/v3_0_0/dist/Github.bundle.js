(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GitHub = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * A Gist can retrieve and modify gists. */ var Gist = function (_Requestable) { _inherits(Gist, _Requestable); /** * Create a Gist. * @param {string} id - the id of the gist (not required when creating a gist) * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Gist(id, auth, apiBase) { _classCallCheck(this, Gist); var _this = _possibleConstructorReturn(this, (Gist.__proto__ || Object.getPrototypeOf(Gist)).call(this, auth, apiBase)); _this.__id = id; return _this; } /** * Fetch a gist. * @see https://developer.github.com/v3/gists/#get-a-single-gist * @param {Requestable.callback} [cb] - will receive the gist * @return {Promise} - the Promise for the http request */ _createClass(Gist, [{ key: 'read', value: function read(cb) { return this._request('GET', '/gists/' + this.__id, null, cb); } /** * Create a new gist. * @see https://developer.github.com/v3/gists/#create-a-gist * @param {Object} gist - the data for the new gist * @param {Requestable.callback} [cb] - will receive the new gist upon creation * @return {Promise} - the Promise for the http request */ }, { key: 'create', value: function create(gist, cb) { var _this2 = this; return this._request('POST', '/gists', gist, cb).then(function (response) { _this2.__id = response.data.id; return response; }); } /** * Delete a gist. * @see https://developer.github.com/v3/gists/#delete-a-gist * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'delete', value: function _delete(cb) { return this._request('DELETE', '/gists/' + this.__id, null, cb); } /** * Fork a gist. * @see https://developer.github.com/v3/gists/#fork-a-gist * @param {Requestable.callback} [cb] - the function that will receive the gist * @return {Promise} - the Promise for the http request */ }, { key: 'fork', value: function fork(cb) { return this._request('POST', '/gists/' + this.__id + '/forks', null, cb); } /** * Update a gist. * @see https://developer.github.com/v3/gists/#edit-a-gist * @param {Object} gist - the new data for the gist * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'update', value: function update(gist, cb) { return this._request('PATCH', '/gists/' + this.__id, gist, cb); } /** * Star a gist. * @see https://developer.github.com/v3/gists/#star-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'star', value: function star(cb) { return this._request('PUT', '/gists/' + this.__id + '/star', null, cb); } /** * Unstar a gist. * @see https://developer.github.com/v3/gists/#unstar-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'unstar', value: function unstar(cb) { return this._request('DELETE', '/gists/' + this.__id + '/star', null, cb); } /** * Check if a gist is starred by the user. * @see https://developer.github.com/v3/gists/#check-if-a-gist-is-starred * @param {Requestable.callback} [cb] - will receive true if the gist is starred and false if the gist is not starred * @return {Promise} - the Promise for the http request */ }, { key: 'isStarred', value: function isStarred(cb) { return this._request204or404('/gists/' + this.__id + '/star', null, cb); } /** * List the gist's comments * @see https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist * @param {Requestable.callback} [cb] - will receive the array of comments * @return {Promise} - the promise for the http request */ }, { key: 'listComments', value: function listComments(cb) { return this._requestAllPages('/gists/' + this.__id + '/comments', null, cb); } /** * Fetch one of the gist's comments * @see https://developer.github.com/v3/gists/comments/#get-a-single-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the Promise for the http request */ }, { key: 'getComment', value: function getComment(comment, cb) { return this._request('GET', '/gists/' + this.__id + '/comments/' + comment, null, cb); } /** * Comment on a gist * @see https://developer.github.com/v3/gists/comments/#create-a-comment * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'createComment', value: function createComment(comment, cb) { return this._request('POST', '/gists/' + this.__id + '/comments', { body: comment }, cb); } /** * Edit a comment on the gist * @see https://developer.github.com/v3/gists/comments/#edit-a-comment * @param {number} comment - the id of the comment * @param {string} body - the new comment * @param {Requestable.callback} [cb] - will receive the modified comment * @return {Promise} - the promise for the http request */ }, { key: 'editComment', value: function editComment(comment, body, cb) { return this._request('PATCH', '/gists/' + this.__id + '/comments/' + comment, { body: body }, cb); } /** * Delete a comment on the gist. * @see https://developer.github.com/v3/gists/comments/#delete-a-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'deleteComment', value: function deleteComment(comment, cb) { return this._request('DELETE', '/gists/' + this.__id + '/comments/' + comment, null, cb); } }]); return Gist; }(_Requestable3.default); 


module.exports = Gist; 

 },{"./Requestable":9}],2:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /* eslint valid-jsdoc: ["error", {"requireReturnDescription": false}] */ var _Gist = require('./Gist'); var _Gist2 = _interopRequireDefault(_Gist); var _User = require('./User'); var _User2 = _interopRequireDefault(_User); var _Issue = require('./Issue'); var _Issue2 = _interopRequireDefault(_Issue); var _Search = require('./Search'); var _Search2 = _interopRequireDefault(_Search); var _RateLimit = require('./RateLimit'); var _RateLimit2 = _interopRequireDefault(_RateLimit); var _Repository = require('./Repository'); var _Repository2 = _interopRequireDefault(_Repository); var _Organization = require('./Organization'); var _Organization2 = _interopRequireDefault(_Organization); var _Team = require('./Team'); var _Team2 = _interopRequireDefault(_Team); var _Markdown = require('./Markdown'); var _Markdown2 = _interopRequireDefault(_Markdown); var _Project = require('./Project'); var _Project2 = _interopRequireDefault(_Project); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /** * GitHub encapsulates the functionality to create various API wrapper objects. */ var GitHub = function () { /** * Create a new GitHub. * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is * not provided requests will be made unauthenticated * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function GitHub(auth) { var apiBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'https://api.github.com'; _classCallCheck(this, GitHub); this.__apiBase = apiBase; this.__auth = auth || {}; } /** * Create a new Gist wrapper * @param {number} [id] - the id for the gist, leave undefined when creating a new gist * @return {Gist} */ _createClass(GitHub, [{ key: 'getGist', value: function getGist(id) { return new _Gist2.default(id, this.__auth, this.__apiBase); } /** * Create a new User wrapper * @param {string} [user] - the name of the user to get information about * leave undefined for the authenticated user * @return {User} */ }, { key: 'getUser', value: function getUser(user) { return new _User2.default(user, this.__auth, this.__apiBase); } /** * Create a new Organization wrapper * @param {string} organization - the name of the organization * @return {Organization} */ }, { key: 'getOrganization', value: function getOrganization(organization) { return new _Organization2.default(organization, this.__auth, this.__apiBase); } /** * create a new Team wrapper * @param {string} teamId - the name of the team * @return {team} */ }, { key: 'getTeam', value: function getTeam(teamId) { return new _Team2.default(teamId, this.__auth, this.__apiBase); } /** * Create a new Repository wrapper * @param {string} user - the user who owns the respository * @param {string} repo - the name of the repository * @return {Repository} */ }, { key: 'getRepo', value: function getRepo(user, repo) { return new _Repository2.default(this._getFullName(user, repo), this.__auth, this.__apiBase); } /** * Create a new Issue wrapper * @param {string} user - the user who owns the respository * @param {string} repo - the name of the repository * @return {Issue} */ }, { key: 'getIssues', value: function getIssues(user, repo) { return new _Issue2.default(this._getFullName(user, repo), this.__auth, this.__apiBase); } /** * Create a new Search wrapper * @param {string} query - the query to search for * @return {Search} */ }, { key: 'search', value: function search(query) { return new _Search2.default(query, this.__auth, this.__apiBase); } /** * Create a new RateLimit wrapper * @return {RateLimit} */ }, { key: 'getRateLimit', value: function getRateLimit() { return new _RateLimit2.default(this.__auth, this.__apiBase); } /** * Create a new Markdown wrapper * @return {Markdown} */ }, { key: 'getMarkdown', value: function getMarkdown() { return new _Markdown2.default(this.__auth, this.__apiBase); } /** * Create a new Project wrapper * @param {string} id - the id of the project * @return {Markdown} */ }, { key: 'getProject', value: function getProject(id) { return new _Project2.default(id, this.__auth, this.__apiBase); } /** * Computes the full repository name * @param {string} user - the username (or the full name) * @param {string} repo - the repository name, must not be passed if `user` is the full name * @return {string} the repository's full name */ }, { key: '_getFullName', value: function _getFullName(user, repo) { var fullname = user; if (repo) { fullname = user + '/' + repo; } return fullname; } }]); return GitHub; }(); module.exports = GitHub; },{"./Gist":1,"./Issue":3,"./Markdown":4,"./Organization":5,"./Project":6,"./RateLimit":7,"./Repository":8,"./Search":10,"./Team":11,"./User":12}],3:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Issue wraps the functionality to get issues for repositories */ var Issue = function (_Requestable) { _inherits(Issue, _Requestable); /** * Create a new Issue * @param {string} repository - the full name of the repository (`:user/:repo`) to get issues for * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Issue(repository, auth, apiBase) { _classCallCheck(this, Issue); var _this = _possibleConstructorReturn(this, (Issue.__proto__ || Object.getPrototypeOf(Issue)).call(this, auth, apiBase)); _this.__repository = repository; return _this; } /** * Create a new issue * @see https://developer.github.com/v3/issues/#create-an-issue * @param {Object} issueData - the issue to create * @param {Requestable.callback} [cb] - will receive the created issue * @return {Promise} - the promise for the http request */ _createClass(Issue, [{ key: 'createIssue', value: function createIssue(issueData, cb) { return this._request('POST', '/repos/' + this.__repository + '/issues', issueData, cb); } /** * List the issues for the repository * @see https://developer.github.com/v3/issues/#list-issues-for-a-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of issues * @return {Promise} - the promise for the http request */ }, { key: 'listIssues', value: function listIssues(options, cb) { return this._requestAllPages('/repos/' + this.__repository + '/issues', options, cb); } /** * List the events for an issue * @see https://developer.github.com/v3/issues/events/#list-events-for-an-issue * @param {number} issue - the issue to get events for * @param {Requestable.callback} [cb] - will receive the list of events * @return {Promise} - the promise for the http request */ }, { key: 'listIssueEvents', value: function listIssueEvents(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/events', null, cb); } /** * List comments on an issue * @see https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue * @param {number} issue - the id of the issue to get comments from * @param {Requestable.callback} [cb] - will receive the comments * @return {Promise} - the promise for the http request */ }, { key: 'listIssueComments', value: function listIssueComments(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/comments', null, cb); } /** * Get a single comment on an issue * @see https://developer.github.com/v3/issues/comments/#get-a-single-comment * @param {number} id - the comment id to get * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the promise for the http request */ }, { key: 'getIssueComment', value: function getIssueComment(id, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb); } /** * Comment on an issue * @see https://developer.github.com/v3/issues/comments/#create-a-comment * @param {number} issue - the id of the issue to comment on * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - will receive the created comment * @return {Promise} - the promise for the http request */ }, { key: 'createIssueComment', value: function createIssueComment(issue, comment, cb) { return this._request('POST', '/repos/' + this.__repository + '/issues/' + issue + '/comments', { body: comment }, cb); } /** * Edit a comment on an issue * @see https://developer.github.com/v3/issues/comments/#edit-a-comment * @param {number} id - the comment id to edit * @param {string} comment - the comment to edit * @param {Requestable.callback} [cb] - will receive the edited comment * @return {Promise} - the promise for the http request */ }, { key: 'editIssueComment', value: function editIssueComment(id, comment, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/issues/comments/' + id, { body: comment }, cb); } /** * Delete a comment on an issue * @see https://developer.github.com/v3/issues/comments/#delete-a-comment * @param {number} id - the comment id to delete * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteIssueComment', value: function deleteIssueComment(id, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb); } /** * Edit an issue * @see https://developer.github.com/v3/issues/#edit-an-issue * @param {number} issue - the issue number to edit * @param {Object} issueData - the new issue data * @param {Requestable.callback} [cb] - will receive the modified issue * @return {Promise} - the promise for the http request */ }, { key: 'editIssue', value: function editIssue(issue, issueData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/issues/' + issue, issueData, cb); } /** * Get a particular issue * @see https://developer.github.com/v3/issues/#get-a-single-issue * @param {number} issue - the issue number to fetch * @param {Requestable.callback} [cb] - will receive the issue * @return {Promise} - the promise for the http request */ }, { key: 'getIssue', value: function getIssue(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue, null, cb); } /** * List the milestones for the repository * @see https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of milestones * @return {Promise} - the promise for the http request */ }, { key: 'listMilestones', value: function listMilestones(options, cb) { return this._request('GET', '/repos/' + this.__repository + '/milestones', options, cb); } /** * Get a milestone * @see https://developer.github.com/v3/issues/milestones/#get-a-single-milestone * @param {string} milestone - the id of the milestone to fetch * @param {Requestable.callback} [cb] - will receive the milestone * @return {Promise} - the promise for the http request */ }, { key: 'getMilestone', value: function getMilestone(milestone, cb) { return this._request('GET', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb); } /** * Create a new milestone * @see https://developer.github.com/v3/issues/milestones/#create-a-milestone * @param {Object} milestoneData - the milestone definition * @param {Requestable.callback} [cb] - will receive the milestone * @return {Promise} - the promise for the http request */ }, { key: 'createMilestone', value: function createMilestone(milestoneData, cb) { return this._request('POST', '/repos/' + this.__repository + '/milestones', milestoneData, cb); } /** * Edit a milestone * @see https://developer.github.com/v3/issues/milestones/#update-a-milestone * @param {string} milestone - the id of the milestone to edit * @param {Object} milestoneData - the updates to make to the milestone * @param {Requestable.callback} [cb] - will receive the updated milestone * @return {Promise} - the promise for the http request */ }, { key: 'editMilestone', value: function editMilestone(milestone, milestoneData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/milestones/' + milestone, milestoneData, cb); } /** * Delete a milestone (this is distinct from closing a milestone) * @see https://developer.github.com/v3/issues/milestones/#delete-a-milestone * @param {string} milestone - the id of the milestone to delete * @param {Requestable.callback} [cb] - will receive the status * @return {Promise} - the promise for the http request */ }, { key: 'deleteMilestone', value: function deleteMilestone(milestone, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb); } /** * Create a new label * @see https://developer.github.com/v3/issues/labels/#create-a-label * @param {Object} labelData - the label definition * @param {Requestable.callback} [cb] - will receive the object representing the label * @return {Promise} - the promise for the http request */ }, { key: 'createLabel', value: function createLabel(labelData, cb) { return this._request('POST', '/repos/' + this.__repository + '/labels', labelData, cb); } /** * List the labels for the repository * @see https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of labels * @return {Promise} - the promise for the http request */ }, { key: 'listLabels', value: function listLabels(options, cb) { return this._request('GET', '/repos/' + this.__repository + '/labels', options, cb); } /** * Get a label * @see https://developer.github.com/v3/issues/labels/#get-a-single-label * @param {string} label - the name of the label to fetch * @param {Requestable.callback} [cb] - will receive the label * @return {Promise} - the promise for the http request */ }, { key: 'getLabel', value: function getLabel(label, cb) { return this._request('GET', '/repos/' + this.__repository + '/labels/' + label, null, cb); } /** * Edit a label * @see https://developer.github.com/v3/issues/labels/#update-a-label * @param {string} label - the name of the label to edit * @param {Object} labelData - the updates to make to the label * @param {Requestable.callback} [cb] - will receive the updated label * @return {Promise} - the promise for the http request */ }, { key: 'editLabel', value: function editLabel(label, labelData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/labels/' + label, labelData, cb); } /** * Delete a label * @see https://developer.github.com/v3/issues/labels/#delete-a-label * @param {string} label - the name of the label to delete * @param {Requestable.callback} [cb] - will receive the status * @return {Promise} - the promise for the http request */ }, { key: 'deleteLabel', value: function deleteLabel(label, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/labels/' + label, null, cb); } }]); return Issue; }(_Requestable3.default);
 
 
 
 module.exports = Issue; 
 
 
 
 
