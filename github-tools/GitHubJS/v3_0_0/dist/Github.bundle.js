
(function(f){
  if(typeof exports==="object"&&typeof module!=="undefined"){
    module.exports=f()
  }else if(typeof define==="function"&&define.amd){
    define([],f)
  }else{
    var g;
    if(typeof window!=="undefined"){
      g=window
    }else if(typeof global!=="undefined"){
      g=global
    }else if(typeof self!=="undefined"){
      g=self
    }else{
      g=this
    }
    g.GitHub = f()
  }
})(function(){
  var define,module,exports;
  return (function e(t,n,r){
    function s(o,u){
      if(!n[o]){
        if(!t[o]){
          var a=typeof require=="function"&&require;
          if(!u&&a)return a(o,!0);
          if(i)return i(o,!0);
          var f=new Error("Cannot find module '"+o+"'");
          throw f.code="MODULE_NOT_FOUND",f
        }
        var l=n[o]={exports:{}};
        t[o][0].call(l.exports,
                     function(e){
          var n=t[o][1][e];return s(n?n:e)
        },l,l.exports,e,t,n,r)
      }return n[o].exports
    }
    var i=typeof require=="function"&&require;
    for(var o=0;o<r.length;o++)s(r[o]);
    return s
  })({
    1:[function(require,module,exports){
      'use strict'; var _createClass = function () { 
        function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); 
      var _Requestable2 = require('./Requestable'); 
      var _Requestable3 = _interopRequireDefault(_Requestable2); 
      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
      /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ 
      /** * A Gist can retrieve and modify gists. */
      var Gist = function (_Requestable) {
        _inherits(Gist, _Requestable); 
        /** * Create a Gist. * @param {string} id - the id of the gist (not required when creating a gist) * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Gist(id, auth, apiBase) { _classCallCheck(this, Gist); var _this = _possibleConstructorReturn(this, (Gist.__proto__ || Object.getPrototypeOf(Gist)).call(this, auth, apiBase)); _this.__id = id; return _this; } /** * Fetch a gist. * @see https://developer.github.com/v3/gists/#get-a-single-gist * @param {Requestable.callback} [cb] - will receive the gist * @return {Promise} - the Promise for the http request */ _createClass(Gist, [{ key: 'read', value: function read(cb) { return this._request('GET', '/gists/' + this.__id, null, cb); } /** * Create a new gist. * @see https://developer.github.com/v3/gists/#create-a-gist * @param {Object} gist - the data for the new gist * @param {Requestable.callback} [cb] - will receive the new gist upon creation * @return {Promise} - the Promise for the http request */ }, { key: 'create', value: function create(gist, cb) { var _this2 = this; return this._request('POST', '/gists', gist, cb).then(function (response) { _this2.__id = response.data.id; return response; }); } /** * Delete a gist. * @see https://developer.github.com/v3/gists/#delete-a-gist * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'delete', value: function _delete(cb) { return this._request('DELETE', '/gists/' + this.__id, null, cb); } /** * Fork a gist. * @see https://developer.github.com/v3/gists/#fork-a-gist * @param {Requestable.callback} [cb] - the function that will receive the gist * @return {Promise} - the Promise for the http request */ }, { key: 'fork', value: function fork(cb) { return this._request('POST', '/gists/' + this.__id + '/forks', null, cb); } /** * Update a gist. * @see https://developer.github.com/v3/gists/#edit-a-gist * @param {Object} gist - the new data for the gist * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'update', value: function update(gist, cb) { return this._request('PATCH', '/gists/' + this.__id, gist, cb); } /** * Star a gist. * @see https://developer.github.com/v3/gists/#star-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'star', value: function star(cb) { return this._request('PUT', '/gists/' + this.__id + '/star', null, cb); } /** * Unstar a gist. * @see https://developer.github.com/v3/gists/#unstar-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'unstar', value: function unstar(cb) { return this._request('DELETE', '/gists/' + this.__id + '/star', null, cb); } /** * Check if a gist is starred by the user. * @see https://developer.github.com/v3/gists/#check-if-a-gist-is-starred * @param {Requestable.callback} [cb] - will receive true if the gist is starred and false if the gist is not starred * @return {Promise} - the Promise for the http request */ }, { key: 'isStarred', value: function isStarred(cb) { return this._request204or404('/gists/' + this.__id + '/star', null, cb); } /** * List the gist's comments * @see https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist * @param {Requestable.callback} [cb] - will receive the array of comments * @return {Promise} - the promise for the http request */ }, { key: 'listComments', value: function listComments(cb) { return this._requestAllPages('/gists/' + this.__id + '/comments', null, cb); } /** * Fetch one of the gist's comments * @see https://developer.github.com/v3/gists/comments/#get-a-single-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the Promise for the http request */ }, { key: 'getComment', value: function getComment(comment, cb) { return this._request('GET', '/gists/' + this.__id + '/comments/' + comment, null, cb); } /** * Comment on a gist * @see https://developer.github.com/v3/gists/comments/#create-a-comment * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'createComment', value: function createComment(comment, cb) { return this._request('POST', '/gists/' + this.__id + '/comments', { body: comment }, cb); }
        
        
        
        
        /** * Edit a comment on the gist * @see https://developer.github.com/v3/gists/comments/#edit-a-comment * @param {number} comment - the id of the comment * @param {string} body - the new comment * @param {Requestable.callback} [cb] - will receive the modified comment * @return {Promise} - the promise for the http request */ }, { key: 'editComment', value: function editComment(comment, body, cb) { return this._request('PATCH', '/gists/' + this.__id + '/comments/' + comment, { body: body }, cb); } /** * Delete a comment on the gist. * @see https://developer.github.com/v3/gists/comments/#delete-a-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'deleteComment', value: function deleteComment(comment, cb) { return this._request('DELETE', '/gists/' + this.__id + '/comments/' + comment, null, cb); } }]); return Gist; }(_Requestable3.default); module.exports = Gist; },{"./Requestable":9}],2:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /* eslint valid-jsdoc: ["error", {"requireReturnDescription": false}] */ var _Gist = require('./Gist'); var _Gist2 = _interopRequireDefault(_Gist); var _User = require('./User'); var _User2 = _interopRequireDefault(_User); var _Issue = require('./Issue'); var _Issue2 = _interopRequireDefault(_Issue); var _Search = require('./Search'); var _Search2 = _interopRequireDefault(_Search); var _RateLimit = require('./RateLimit'); var _RateLimit2 = _interopRequireDefault(_RateLimit); var _Repository = require('./Repository'); var _Repository2 = _interopRequireDefault(_Repository); var _Organization = require('./Organization'); var _Organization2 = _interopRequireDefault(_Organization); var _Team = require('./Team'); var _Team2 = _interopRequireDefault(_Team); var _Markdown = require('./Markdown'); var _Markdown2 = _interopRequireDefault(_Markdown); var _Project = require('./Project'); var _Project2 = _interopRequireDefault(_Project); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } 
        
        
        /** * GitHub encapsulates the functionality to create various API wrapper objects.
        */ var GitHub = function () {
          /** * Create a new GitHub. * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is * not provided requests will be made unauthenticated * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function GitHub(auth) { var apiBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'https://api.github.com'; _classCallCheck(this, GitHub); this.__apiBase = apiBase; this.__auth = auth || {}; } /** * Create a new Gist wrapper * @param {number} [id] - the id for the gist, leave undefined when creating a new gist * @return {Gist} */ _createClass(GitHub, [{ key: 'getGist', value: function getGist(id) { return new _Gist2.default(id, this.__auth, this.__apiBase); } /** * Create a new User wrapper * @param {string} [user] - the name of the user to get information about * leave undefined for the authenticated user * @return {User} */ }, { key: 'getUser', value: function getUser(user) { return new _User2.default(user, this.__auth, this.__apiBase); } /** * Create a new Organization wrapper * @param {string} organization - the name of the organization * @return {Organization} */ }, { key: 'getOrganization', value: function getOrganization(organization) { return new _Organization2.default(organization, this.__auth, this.__apiBase); } /** * create a new Team wrapper * @param {string} teamId - the name of the team * @return {team} */ }, { key: 'getTeam', value: function getTeam(teamId) { return new _Team2.default(teamId, this.__auth, this.__apiBase); } /** * Create a new Repository wrapper * @param {string} user - the user who owns the respository * @param {string} repo - the name of the repository * @return {Repository} */ }, { key: 'getRepo', value: function getRepo(user, repo) { return new _Repository2.default(this._getFullName(user, repo), this.__auth, this.__apiBase); } /** * Create a new Issue wrapper * @param {string} user - the user who owns the respository * @param {string} repo - the name of the repository * @return {Issue} */ }, { key: 'getIssues', value: function getIssues(user, repo) { return new _Issue2.default(this._getFullName(user, repo), this.__auth, this.__apiBase); } /** * Create a new Search wrapper * @param {string} query - the query to search for * @return {Search} */ }, { key: 'search', value: function search(query) { return new _Search2.default(query, this.__auth, this.__apiBase); } /** * Create a new RateLimit wrapper * @return {RateLimit} */ }, { key: 'getRateLimit', value: function getRateLimit() { return new _RateLimit2.default(this.__auth, this.__apiBase); } /** * Create a new Markdown wrapper * @return {Markdown} */ }, { key: 'getMarkdown', value: function getMarkdown() { return new _Markdown2.default(this.__auth, this.__apiBase); } /** * Create a new Project wrapper * @param {string} id - the id of the project * @return {Markdown} */ }, { key: 'getProject', value: function getProject(id) { return new _Project2.default(id, this.__auth, this.__apiBase); } /** * Computes the full repository name * @param {string} user - the username (or the full name) * @param {string} repo - the repository name, must not be passed if `user` is the full name * @return {string} the repository's full name */ }, { key: '_getFullName', value: function _getFullName(user, repo) { var fullname = user; if (repo) { fullname = user + '/' + repo; } return fullname; } }]); return GitHub; }(); module.exports = GitHub; },{"./Gist":1,"./Issue":3,"./Markdown":4,"./Organization":5,"./Project":6,"./RateLimit":7,"./Repository":8,"./Search":10,"./Team":11,"./User":12}],3:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Issue wraps the functionality to get issues for repositories */ var Issue = function (_Requestable) { _inherits(Issue, _Requestable); /** * Create a new Issue * @param {string} repository - the full name of the repository (`:user/:repo`) to get issues for * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Issue(repository, auth, apiBase) { _classCallCheck(this, Issue); var _this = _possibleConstructorReturn(this, (Issue.__proto__ || Object.getPrototypeOf(Issue)).call(this, auth, apiBase)); _this.__repository = repository; return _this; } /** * Create a new issue * @see https://developer.github.com/v3/issues/#create-an-issue * @param {Object} issueData - the issue to create * @param {Requestable.callback} [cb] - will receive the created issue * @return {Promise} - the promise for the http request */ _createClass(Issue, [{ key: 'createIssue', value: function createIssue(issueData, cb) { return this._request('POST', '/repos/' + this.__repository + '/issues', issueData, cb); } /** * List the issues for the repository * @see https://developer.github.com/v3/issues/#list-issues-for-a-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of issues * @return {Promise} - the promise for the http request */ }, { key: 'listIssues', value: function listIssues(options, cb) { return this._requestAllPages('/repos/' + this.__repository + '/issues', options, cb); } /** * List the events for an issue * @see https://developer.github.com/v3/issues/events/#list-events-for-an-issue * @param {number} issue - the issue to get events for * @param {Requestable.callback} [cb] - will receive the list of events * @return {Promise} - the promise for the http request */ }, { key: 'listIssueEvents', value: function listIssueEvents(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/events', null, cb); } /** * List comments on an issue * @see https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue * @param {number} issue - the id of the issue to get comments from * @param {Requestable.callback} [cb] - will receive the comments * @return {Promise} - the promise for the http request */ }, { key: 'listIssueComments', value: function listIssueComments(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/comments', null, cb); } /** * Get a single comment on an issue * @see https://developer.github.com/v3/issues/comments/#get-a-single-comment * @param {number} id - the comment id to get * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the promise for the http request */ }, { key: 'getIssueComment', value: function getIssueComment(id, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb); } /** * Comment on an issue * @see https://developer.github.com/v3/issues/comments/#create-a-comment * @param {number} issue - the id of the issue to comment on * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - will receive the created comment * @return {Promise} - the promise for the http request */ }, { key: 'createIssueComment', value: function createIssueComment(issue, comment, cb) { return this._request('POST', '/repos/' + this.__repository + '/issues/' + issue + '/comments', { body: comment }, cb); } /** * Edit a comment on an issue * @see https://developer.github.com/v3/issues/comments/#edit-a-comment * @param {number} id - the comment id to edit * @param {string} comment - the comment to edit * @param {Requestable.callback} [cb] - will receive the edited comment * @return {Promise} - the promise for the http request */ }, { key: 'editIssueComment', value: function editIssueComment(id, comment, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/issues/comments/' + id, { body: comment }, cb); } /** * Delete a comment on an issue * @see https://developer.github.com/v3/issues/comments/#delete-a-comment * @param {number} id - the comment id to delete * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteIssueComment', value: function deleteIssueComment(id, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb); } /** * Edit an issue * @see https://developer.github.com/v3/issues/#edit-an-issue * @param {number} issue - the issue number to edit * @param {Object} issueData - the new issue data * @param {Requestable.callback} [cb] - will receive the modified issue * @return {Promise} - the promise for the http request */ }, { key: 'editIssue', value: function editIssue(issue, issueData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/issues/' + issue, issueData, cb); } /** * Get a particular issue * @see https://developer.github.com/v3/issues/#get-a-single-issue * @param {number} issue - the issue number to fetch * @param {Requestable.callback} [cb] - will receive the issue * @return {Promise} - the promise for the http request */ }, { key: 'getIssue', value: function getIssue(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue, null, cb); } /** * List the milestones for the repository * @see https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of milestones * @return {Promise} - the promise for the http request */ }, { key: 'listMilestones', value: function listMilestones(options, cb) { return this._request('GET', '/repos/' + this.__repository + '/milestones', options, cb); } /** * Get a milestone * @see https://developer.github.com/v3/issues/milestones/#get-a-single-milestone * @param {string} milestone - the id of the milestone to fetch * @param {Requestable.callback} [cb] - will receive the milestone * @return {Promise} - the promise for the http request */ }, { key: 'getMilestone', value: function getMilestone(milestone, cb) { return this._request('GET', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb); } /** * Create a new milestone * @see https://developer.github.com/v3/issues/milestones/#create-a-milestone * @param {Object} milestoneData - the milestone definition * @param {Requestable.callback} [cb] - will receive the milestone * @return {Promise} - the promise for the http request */ }, { key: 'createMilestone', value: function createMilestone(milestoneData, cb) { return this._request('POST', '/repos/' + this.__repository + '/milestones', milestoneData, cb); } /** * Edit a milestone * @see https://developer.github.com/v3/issues/milestones/#update-a-milestone * @param {string} milestone - the id of the milestone to edit * @param {Object} milestoneData - the updates to make to the milestone * @param {Requestable.callback} [cb] - will receive the updated milestone * @return {Promise} - the promise for the http request */ }, { key: 'editMilestone', value: function editMilestone(milestone, milestoneData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/milestones/' + milestone, milestoneData, cb); } /** * Delete a milestone (this is distinct from closing a milestone) * @see https://developer.github.com/v3/issues/milestones/#delete-a-milestone * @param {string} milestone - the id of the milestone to delete * @param {Requestable.callback} [cb] - will receive the status * @return {Promise} - the promise for the http request */ }, { key: 'deleteMilestone', value: function deleteMilestone(milestone, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb); } /** * Create a new label * @see https://developer.github.com/v3/issues/labels/#create-a-label * @param {Object} labelData - the label definition * @param {Requestable.callback} [cb] - will receive the object representing the label * @return {Promise} - the promise for the http request */ }, { key: 'createLabel', value: function createLabel(labelData, cb) { return this._request('POST', '/repos/' + this.__repository + '/labels', labelData, cb); } /** * List the labels for the repository * @see https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of labels * @return {Promise} - the promise for the http request */ }, { key: 'listLabels', value: function listLabels(options, cb) { return this._request('GET', '/repos/' + this.__repository + '/labels', options, cb); } /** * Get a label * @see https://developer.github.com/v3/issues/labels/#get-a-single-label * @param {string} label - the name of the label to fetch * @param {Requestable.callback} [cb] - will receive the label * @return {Promise} - the promise for the http request */ }, { key: 'getLabel', value: function getLabel(label, cb) { return this._request('GET', '/repos/' + this.__repository + '/labels/' + label, null, cb); } /** * Edit a label * @see https://developer.github.com/v3/issues/labels/#update-a-label * @param {string} label - the name of the label to edit * @param {Object} labelData - the updates to make to the label * @param {Requestable.callback} [cb] - will receive the updated label * @return {Promise} - the promise for the http request */ }, { key: 'editLabel', value: function editLabel(label, labelData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/labels/' + label, labelData, cb); } /** * Delete a label * @see https://developer.github.com/v3/issues/labels/#delete-a-label * @param {string} label - the name of the label to delete * @param {Requestable.callback} [cb] - will receive the status * @return {Promise} - the promise for the http request */ }, { key: 'deleteLabel', value: function deleteLabel(label, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/labels/' + label, null, cb); } }]); return Issue; }(_Requestable3.default); module.exports = Issue; },{"./Requestable":9}],4:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Renders html from Markdown text */ var Markdown = function (_Requestable) { _inherits(Markdown, _Requestable); /** * construct a Markdown * @param {Requestable.auth} auth - the credentials to authenticate to GitHub * @param {string} [apiBase] - the base Github API URL * @return {Promise} - the promise for the http request */ function Markdown(auth, apiBase) { _classCallCheck(this, Markdown); return _possibleConstructorReturn(this, (Markdown.__proto__ || Object.getPrototypeOf(Markdown)).call(this, auth, apiBase)); } /** * Render html from Markdown text. * @see https://developer.github.com/v3/markdown/#render-an-arbitrary-markdown-document * @param {Object} options - conversion options * @param {string} [options.text] - the markdown text to convert * @param {string} [options.mode=markdown] - can be either `markdown` or `gfm` * @param {string} [options.context] - repository name if mode is gfm * @param {Requestable.callback} [cb] - will receive the converted html * @return {Promise} - the promise for the http request */ _createClass(Markdown, [{ key: 'render', value: function render(options, cb) { return this._request('POST', '/markdown', options, cb); } }]); return Markdown; }(_Requestable3.default); module.exports = Markdown; },{"./Requestable":9}],5:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Organization encapsulates the functionality to create repositories in organizations */ var Organization = function (_Requestable) { _inherits(Organization, _Requestable); /** * Create a new Organization * @param {string} organization - the name of the organization * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Organization(organization, auth, apiBase) { _classCallCheck(this, Organization); var _this = _possibleConstructorReturn(this, (Organization.__proto__ || Object.getPrototypeOf(Organization)).call(this, auth, apiBase)); _this.__name = organization; return _this; } /** * Create a repository in an organization * @see https://developer.github.com/v3/repos/#create * @param {Object} options - the repository definition * @param {Requestable.callback} [cb] - will receive the created repository * @return {Promise} - the promise for the http request */ _createClass(Organization, [{ key: 'createRepo', value: function createRepo(options, cb) { return this._request('POST', '/orgs/' + this.__name + '/repos', options, cb); } /** * List the repositories in an organization * @see https://developer.github.com/v3/repos/#list-organization-repositories * @param {Requestable.callback} [cb] - will receive the list of repositories * @return {Promise} - the promise for the http request */ }, { key: 'getRepos', value: function getRepos(cb) { var requestOptions = this._getOptionsWithDefaults({ direction: 'desc' }); return this._requestAllPages('/orgs/' + this.__name + '/repos', requestOptions, cb); } /** * Query if the user is a member or not * @param {string} username - the user in question * @param {Requestable.callback} [cb] - will receive true if the user is a member * @return {Promise} - the promise for the http request */ }, { key: 'isMember', value: function isMember(username, cb) { return this._request204or404('/orgs/' + this.__name + '/members/' + username, null, cb); } /** * List the users who are members of the company * @see https://developer.github.com/v3/orgs/members/#members-list * @param {object} options - filtering options * @param {string} [options.filter=all] - can be either `2fa_disabled` or `all` * @param {string} [options.role=all] - can be one of: `all`, `admin`, or `member` * @param {Requestable.callback} [cb] - will receive the list of users * @return {Promise} - the promise for the http request */ }, { key: 'listMembers', value: function listMembers(options, cb) { return this._request('GET', '/orgs/' + this.__name + '/members', options, cb); } /** * List the Teams in the Organization * @see https://developer.github.com/v3/orgs/teams/#list-teams * @param {Requestable.callback} [cb] - will receive the list of teams * @return {Promise} - the promise for the http request */ }, { key: 'getTeams', value: function getTeams(cb) { return this._requestAllPages('/orgs/' + this.__name + '/teams', undefined, cb); } /** * Create a team * @see https://developer.github.com/v3/orgs/teams/#create-team * @param {object} options - Team creation parameters * @param {string} options.name - The name of the team * @param {string} [options.description] - Team description * @param {string} [options.repo_names] - Repos to add the team to * @param {string} [options.privacy=secret] - The level of privacy the team should have. Can be either one * of: `secret`, or `closed` * @param {Requestable.callback} [cb] - will receive the created team * @return {Promise} - the promise for the http request */ }, { key: 'createTeam', value: function createTeam(options, cb) { return this._request('POST', '/orgs/' + this.__name + '/teams', options, cb); } /** * Get information about all projects * @see https://developer.github.com/v3/projects/#list-organization-projects * @param {Requestable.callback} [cb] - will receive the list of projects * @return {Promise} - the promise for the http request */ }, { key: 'listProjects', value: function listProjects(cb) { return this._requestAllPages('/orgs/' + this.__name + '/projects', { AcceptHeader: 'inertia-preview' }, cb); } /** * Create a new project * @see https://developer.github.com/v3/repos/projects/#create-a-project * @param {Object} options - the description of the project * @param {Requestable.callback} cb - will receive the newly created project * @return {Promise} - the promise for the http request */ }, { key: 'createProject', value: function createProject(options, cb) { options = options || {}; options.AcceptHeader = 'inertia-preview'; return this._request('POST', '/orgs/' + this.__name + '/projects', options, cb); } }]); return Organization; }(_Requestable3.default); module.exports = Organization; },{"./Requestable":9}],6:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Project encapsulates the functionality to create, query, and modify cards and columns. */ var Project = function (_Requestable) { _inherits(Project, _Requestable); /** * Create a Project. * @param {string} id - the id of the project * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Project(id, auth, apiBase) { _classCallCheck(this, Project); var _this = _possibleConstructorReturn(this, (Project.__proto__ || Object.getPrototypeOf(Project)).call(this, auth, apiBase, 'inertia-preview')); _this.__id = id; return _this; } /** * Get information about a project * @see https://developer.github.com/v3/projects/#get-a-project * @param {Requestable.callback} cb - will receive the project information * @return {Promise} - the promise for the http request */ _createClass(Project, [{ key: 'getProject', value: function getProject(cb) { return this._request('GET', '/projects/' + this.__id, null, cb); } /** * Edit a project * @see https://developer.github.com/v3/projects/#update-a-project * @param {Object} options - the description of the project * @param {Requestable.callback} cb - will receive the modified project * @return {Promise} - the promise for the http request */ }, { key: 'updateProject', value: function updateProject(options, cb) { return this._request('PATCH', '/projects/' + this.__id, options, cb); } /** * Delete a project * @see https://developer.github.com/v3/projects/#delete-a-project * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteProject', value: function deleteProject(cb) { return this._request('DELETE', '/projects/' + this.__id, null, cb); } /** * Get information about all columns of a project * @see https://developer.github.com/v3/projects/columns/#list-project-columns * @param {Requestable.callback} [cb] - will receive the list of columns * @return {Promise} - the promise for the http request */ }, { key: 'listProjectColumns', value: function listProjectColumns(cb) { return this._requestAllPages('/projects/' + this.__id + '/columns', null, cb); } /** * Get information about a column * @see https://developer.github.com/v3/projects/columns/#get-a-project-column * @param {string} colId - the id of the column * @param {Requestable.callback} cb - will receive the column information * @return {Promise} - the promise for the http request */ }, { key: 'getProjectColumn', value: function getProjectColumn(colId, cb) { return this._request('GET', '/projects/columns/' + colId, null, cb); } /** * Create a new column * @see https://developer.github.com/v3/projects/columns/#create-a-project-column * @param {Object} options - the description of the column * @param {Requestable.callback} cb - will receive the newly created column * @return {Promise} - the promise for the http request */ }, { key: 'createProjectColumn', value: function createProjectColumn(options, cb) { return this._request('POST', '/projects/' + this.__id + '/columns', options, cb); } /** * Edit a column * @see https://developer.github.com/v3/projects/columns/#update-a-project-column * @param {string} colId - the column id * @param {Object} options - the description of the column * @param {Requestable.callback} cb - will receive the modified column * @return {Promise} - the promise for the http request */ }, { key: 'updateProjectColumn', value: function updateProjectColumn(colId, options, cb) { return this._request('PATCH', '/projects/columns/' + colId, options, cb); } /** * Delete a column * @see https://developer.github.com/v3/projects/columns/#delete-a-project-column * @param {string} colId - the column to be deleted * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteProjectColumn', value: function deleteProjectColumn(colId, cb) { return this._request('DELETE', '/projects/columns/' + colId, null, cb); } /** * Move a column * @see https://developer.github.com/v3/projects/columns/#move-a-project-column * @param {string} colId - the column to be moved * @param {string} position - can be one of first, last, or after:<column-id>, * where <column-id> is the id value of a column in the same project. * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'moveProjectColumn', value: function moveProjectColumn(colId, position, cb) { return this._request('POST', '/projects/columns/' + colId + '/moves', { position: position }, cb); } /** * Get information about all cards of a project * @see https://developer.github.com/v3/projects/cards/#list-project-cards * @param {Requestable.callback} [cb] - will receive the list of cards * @return {Promise} - the promise for the http request */ }, { key: 'listProjectCards', value: function listProjectCards(cb) { var _this2 = this; return this.listProjectColumns().then(function (_ref) { var data = _ref.data; return Promise.all(data.map(function (column) { return _this2._requestAllPages('/projects/columns/' + column.id + '/cards', null); })); }).then(function (cardsInColumns) { var cards = cardsInColumns.reduce(function (prev, _ref2) { var data = _ref2.data; prev.push.apply(prev, _toConsumableArray(data)); return prev; }, []); if (cb) { cb(null, cards); } return cards; }).catch(function (err) { if (cb) { cb(err); return; } throw err; }); } /** * Get information about all cards of a column * @see https://developer.github.com/v3/projects/cards/#list-project-cards * @param {string} colId - the id of the column * @param {Requestable.callback} [cb] - will receive the list of cards * @return {Promise} - the promise for the http request */ }, { key: 'listColumnCards', value: function listColumnCards(colId, cb) { return this._requestAllPages('/projects/columns/' + colId + '/cards', null, cb); } /** * Get information about a card * @see https://developer.github.com/v3/projects/cards/#get-a-project-card * @param {string} cardId - the id of the card * @param {Requestable.callback} cb - will receive the card information * @return {Promise} - the promise for the http request */ }, { key: 'getProjectCard', value: function getProjectCard(cardId, cb) { return this._request('GET', '/projects/columns/cards/' + cardId, null, cb); } /** * Create a new card * @see https://developer.github.com/v3/projects/cards/#create-a-project-card * @param {string} colId - the column id * @param {Object} options - the description of the card * @param {Requestable.callback} cb - will receive the newly created card * @return {Promise} - the promise for the http request */ }, { key: 'createProjectCard', value: function createProjectCard(colId, options, cb) { return this._request('POST', '/projects/columns/' + colId + '/cards', options, cb); } /** * Edit a card * @see https://developer.github.com/v3/projects/cards/#update-a-project-card * @param {string} cardId - the card id * @param {Object} options - the description of the card * @param {Requestable.callback} cb - will receive the modified card * @return {Promise} - the promise for the http request */ }, { key: 'updateProjectCard', value: function updateProjectCard(cardId, options, cb) { return this._request('PATCH', '/projects/columns/cards/' + cardId, options, cb); } /** * Delete a card * @see https://developer.github.com/v3/projects/cards/#delete-a-project-card * @param {string} cardId - the card to be deleted * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteProjectCard', value: function deleteProjectCard(cardId, cb) { return this._request('DELETE', '/projects/columns/cards/' + cardId, null, cb); } /** * Move a card * @see https://developer.github.com/v3/projects/cards/#move-a-project-card * @param {string} cardId - the card to be moved * @param {string} position - can be one of top, bottom, or after:<card-id>, * where <card-id> is the id value of a card in the same project. * @param {string} colId - the id value of a column in the same project. * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'moveProjectCard', value: function moveProjectCard(cardId, position, colId, cb) { return this._request('POST', '/projects/columns/cards/' + cardId + '/moves', { position: position, column_id: colId }, // eslint-disable-line camelcase cb); } }]); return Project; }(_Requestable3.default); module.exports = Project; },{"./Requestable":9}],7:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * RateLimit allows users to query their rate-limit status */ var RateLimit = function (_Requestable) { _inherits(RateLimit, _Requestable); /** * construct a RateLimit * @param {Requestable.auth} auth - the credentials to authenticate to GitHub * @param {string} [apiBase] - the base Github API URL * @return {Promise} - the promise for the http request */ function RateLimit(auth, apiBase) { _classCallCheck(this, RateLimit); return _possibleConstructorReturn(this, (RateLimit.__proto__ || Object.getPrototypeOf(RateLimit)).call(this, auth, apiBase)); } /** * Query the current rate limit * @see https://developer.github.com/v3/rate_limit/ * @param {Requestable.callback} [cb] - will receive the rate-limit data * @return {Promise} - the promise for the http request */ _createClass(RateLimit, [{ key: 'getRateLimit', value: function getRateLimit(cb) { return this._request('GET', '/rate_limit', null, cb); } }]); return RateLimit; }(_Requestable3.default); module.exports = RateLimit; },{"./Requestable":9}],8:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); var _utf = require('utf8'); var _utf2 = _interopRequireDefault(_utf); var _jsBase = require('js-base64'); var _debug = require('debug'); var _debug2 = _interopRequireDefault(_debug); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ var log = (0, _debug2.default)('github:repository'); /** * Respository encapsulates the functionality to create, query, and modify files. */ var Repository = function (_Requestable) { _inherits(Repository, _Requestable); /** * Create a Repository. * @param {string} fullname - the full name of the repository * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Repository(fullname, auth, apiBase) { _classCallCheck(this, Repository); var _this = _possibleConstructorReturn(this, (Repository.__proto__ || Object.getPrototypeOf(Repository)).call(this, auth, apiBase)); _this.__fullname = fullname; _this.__currentTree = { branch: null, sha: null }; return _this; } /** * Get a reference * @see https://developer.github.com/v3/git/refs/#get-a-reference * @param {string} ref - the reference to get * @param {Requestable.callback} [cb] - will receive the reference's refSpec or a list of refSpecs that match `ref` * @return {Promise} - the promise for the http request */ _createClass(Repository, [{ key: 'getRef', value: function getRef(ref, cb) { return this._request('GET', '/repos/' + this.__fullname + '/git/refs/' + ref, null, cb); } /** * Create a reference * @see https://developer.github.com/v3/git/refs/#create-a-reference * @param {Object} options - the object describing the ref * @param {Requestable.callback} [cb] - will receive the ref * @return {Promise} - the promise for the http request */ }, { key: 'createRef', value: function createRef(options, cb) { return this._request('POST', '/repos/' + this.__fullname + '/git/refs', options, cb); } /** * Delete a reference * @see https://developer.github.com/v3/git/refs/#delete-a-reference * @param {string} ref - the name of the ref to delte * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteRef', value: function deleteRef(ref, cb) { return this._request('DELETE', '/repos/' + this.__fullname + '/git/refs/' + ref, null, cb); } /** * Delete a repository * @see https://developer.github.com/v3/repos/#delete-a-repository * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteRepo', value: function deleteRepo(cb) { return this._request('DELETE', '/repos/' + this.__fullname, null, cb); } /** * List the tags on a repository * @see https://developer.github.com/v3/repos/#list-tags * @param {Requestable.callback} [cb] - will receive the tag data * @return {Promise} - the promise for the http request */ }, { key: 'listTags', value: function listTags(cb) { return this._request('GET', '/repos/' + this.__fullname + '/tags', null, cb); } /** * List the open pull requests on the repository * @see https://developer.github.com/v3/pulls/#list-pull-requests * @param {Object} options - options to filter the search * @param {Requestable.callback} [cb] - will receive the list of PRs * @return {Promise} - the promise for the http request */ }, { key: 'listPullRequests', value: function listPullRequests(options, cb) { options = options || {}; return this._request('GET', '/repos/' + this.__fullname + '/pulls', options, cb); } /** * Get information about a specific pull request * @see https://developer.github.com/v3/pulls/#get-a-single-pull-request * @param {number} number - the PR you wish to fetch * @param {Requestable.callback} [cb] - will receive the PR from the API * @return {Promise} - the promise for the http request */ }, { key: 'getPullRequest', value: function getPullRequest(number, cb) { return this._request('GET', '/repos/' + this.__fullname + '/pulls/' + number, null, cb); } /** * List the files of a specific pull request * @see https://developer.github.com/v3/pulls/#list-pull-requests-files * @param {number|string} number - the PR you wish to fetch * @param {Requestable.callback} [cb] - will receive the list of files from the API * @return {Promise} - the promise for the http request */ }, { key: 'listPullRequestFiles', value: function listPullRequestFiles(number, cb) { return this._request('GET', '/repos/' + this.__fullname + '/pulls/' + number + '/files', null, cb); } /** * Compare two branches/commits/repositories * @see https://developer.github.com/v3/repos/commits/#compare-two-commits * @param {string} base - the base commit * @param {string} head - the head commit * @param {Requestable.callback} cb - will receive the comparison * @return {Promise} - the promise for the http request */ }, { key: 'compareBranches', value: function compareBranches(base, head, cb) { return this._request('GET', '/repos/' + this.__fullname + '/compare/' + base + '...' + head, null, cb); } /** * List all the branches for the repository * @see https://developer.github.com/v3/repos/#list-branches * @param {Requestable.callback} cb - will receive the list of branches * @return {Promise} - the promise for the http request */ }, { key: 'listBranches', value: function listBranches(cb) { return this._request('GET', '/repos/' + this.__fullname + '/branches', null, cb); } /** * Get a raw blob from the repository * @see https://developer.github.com/v3/git/blobs/#get-a-blob * @param {string} sha - the sha of the blob to fetch * @param {Requestable.callback} cb - will receive the blob from the API * @return {Promise} - the promise for the http request */ }, { key: 'getBlob', value: function getBlob(sha, cb) { return this._request('GET', '/repos/' + this.__fullname + '/git/blobs/' + sha, null, cb, 'raw'); } /** * Get a single branch * @see https://developer.github.com/v3/repos/branches/#get-branch * @param {string} branch - the name of the branch to fetch * @param {Requestable.callback} cb - will receive the branch from the API * @returns {Promise} - the promise for the http request */ }, { key: 'getBranch', value: function getBranch(branch, cb) { return this._request('GET', '/repos/' + this.__fullname + '/branches/' + branch, null, cb); } /** * Get a commit from the repository * @see https://developer.github.com/v3/repos/commits/#get-a-single-commit * @param {string} sha - the sha for the commit to fetch * @param {Requestable.callback} cb - will receive the commit data * @return {Promise} - the promise for the http request */ }, { key: 'getCommit', value: function getCommit(sha, cb) { return this._request('GET', '/repos/' + this.__fullname + '/git/commits/' + sha, null, cb); } /** * List the commits on a repository, optionally filtering by path, author or time range * @see https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository * @param {Object} [options] - the filtering options for commits * @param {string} [options.sha] - the SHA or branch to start from * @param {string} [options.path] - the path to search on * @param {string} [options.author] - the commit author * @param {(Date|string)} [options.since] - only commits after this date will be returned * @param {(Date|string)} [options.until] - only commits before this date will be returned * @param {Requestable.callback} cb - will receive the list of commits found matching the criteria * @return {Promise} - the promise for the http request */ }, { key: 'listCommits', value: function listCommits(options, cb) { options = options || {}; options.since = this._dateToISO(options.since); options.until = this._dateToISO(options.until); return this._request('GET', '/repos/' + this.__fullname + '/commits', options, cb); } /** * Gets a single commit information for a repository * @see https://developer.github.com/v3/repos/commits/#get-a-single-commit * @param {string} ref - the reference for the commit-ish * @param {Requestable.callback} cb - will receive the commit information * @return {Promise} - the promise for the http request */ }, { key: 'getSingleCommit', value: function getSingleCommit(ref, cb) { ref = ref || ''; return this._request('GET', '/repos/' + this.__fullname + '/commits/' + ref, null, cb); } /** * Get tha sha for a particular object in the repository. This is a convenience function * @see https://developer.github.com/v3/repos/contents/#get-contents * @param {string} [branch] - the branch to look in, or the repository's default branch if omitted * @param {string} path - the path of the file or directory * @param {Requestable.callback} cb - will receive a description of the requested object, including a `SHA` property * @return {Promise} - the promise for the http request */ }, { key: 'getSha', value: function getSha(branch, path, cb) { branch = branch ? '?ref=' + branch : ''; return this._request('GET', '/repos/' + this.__fullname + '/contents/' + path + branch, null, cb); } /** * List the commit statuses for a particular sha, branch, or tag * @see https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref * @param {string} sha - the sha, branch, or tag to get statuses for * @param {Requestable.callback} cb - will receive the list of statuses * @return {Promise} - the promise for the http request */ }, { key: 'listStatuses', value: function listStatuses(sha, cb) { return this._request('GET', '/repos/' + this.__fullname + '/commits/' + sha + '/statuses', null, cb); } /** * Get a description of a git tree * @see https://developer.github.com/v3/git/trees/#get-a-tree * @param {string} treeSHA - the SHA of the tree to fetch * @param {Requestable.callback} cb - will receive the callback data * @return {Promise} - the promise for the http request */ }, { key: 'getTree', value: function getTree(treeSHA, cb) { return this._request('GET', '/repos/' + this.__fullname + '/git/trees/' + treeSHA, null, cb); } /** * Create a blob * @see https://developer.github.com/v3/git/blobs/#create-a-blob * @param {(string|Buffer|Blob)} content - the content to add to the repository * @param {Requestable.callback} cb - will receive the details of the created blob * @return {Promise} - the promise for the http request */ }, { key: 'createBlob', value: function createBlob(content, cb) { var postBody = this._getContentObject(content); log('sending content', postBody); return this._request('POST', '/repos/' + this.__fullname + '/git/blobs', postBody, cb); } /** * Get the object that represents the provided content * @param {string|Buffer|Blob} content - the content to send to the server * @return {Object} the representation of `content` for the GitHub API */ }, { key: '_getContentObject', value: function _getContentObject(content) { if (typeof content === 'string') { log('contet is a string'); return { content: _utf2.default.encode(content), encoding: 'utf-8' }; } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) { log('We appear to be in Node'); return { content: content.toString('base64'), encoding: 'base64' }; } else if (typeof Blob !== 'undefined' && content instanceof Blob) { log('We appear to be in the browser'); return { content: _jsBase.Base64.encode(content), encoding: 'base64' }; } else { // eslint-disable-line log('Not sure what this content is: ' + (typeof content === 'undefined' ? 'undefined' : _typeof(content)) + ', ' + JSON.stringify(content)); throw new Error('Unknown content passed to postBlob. Must be string or Buffer (node) or Blob (web)'); } } /** * Update a tree in Git * @see https://developer.github.com/v3/git/trees/#create-a-tree * @param {string} baseTreeSHA - the SHA of the tree to update * @param {string} path - the path for the new file * @param {string} blobSHA - the SHA for the blob to put at `path` * @param {Requestable.callback} cb - will receive the new tree that is created * @return {Promise} - the promise for the http request * @deprecated use {@link Repository#createTree} instead */ }, { key: 'updateTree', value: function updateTree(baseTreeSHA, path, blobSHA, cb) { var newTree = { base_tree: baseTreeSHA, // eslint-disable-line tree: [{ path: path, sha: blobSHA, mode: '100644', type: 'blob' }] }; return this._request('POST', '/repos/' + this.__fullname + '/git/trees', newTree, cb); } /** * Create a new tree in git * @see https://developer.github.com/v3/git/trees/#create-a-tree * @param {Object} tree - the tree to create * @param {string} baseSHA - the root sha of the tree * @param {Requestable.callback} cb - will receive the new tree that is created * @return {Promise} - the promise for the http request */ }, { key: 'createTree', value: function createTree(tree, baseSHA, cb) { return this._request('POST', '/repos/' + this.__fullname + '/git/trees', { tree: tree, base_tree: baseSHA }, cb); } /** * Add a commit to the repository * @see https://developer.github.com/v3/git/commits/#create-a-commit * @param {string} parent - the SHA of the parent commit * @param {string} tree - the SHA of the tree for this commit * @param {string} message - the commit message * @param {Requestable.callback} cb - will receive the commit that is created * @return {Promise} - the promise for the http request */ }, { key: 'commit', value: function commit(parent, tree, message, cb) { var _this2 = this; var data = { message: message, tree: tree, parents: [parent] }; return this._request('POST', '/repos/' + this.__fullname + '/git/commits', data, cb).then(function (response) { _this2.__currentTree.sha = response.data.sha; // Update latest commit return response; }); } /** * Update a ref * @see https://developer.github.com/v3/git/refs/#update-a-reference * @param {string} ref - the ref to update * @param {string} commitSHA - the SHA to point the reference to * @param {boolean} force - indicates whether to force or ensure a fast-forward update * @param {Requestable.callback} cb - will receive the updated ref back * @return {Promise} - the promise for the http request */ }, { key: 'updateHead', value: function updateHead(ref, commitSHA, force, cb) { return this._request('PATCH', '/repos/' + this.__fullname + '/git/refs/' + ref, { sha: commitSHA, force: force }, cb); } /** * Update commit status * @see https://developer.github.com/v3/repos/statuses/ * @param {string} commitSHA - the SHA of the commit that should be updated * @param {object} options - Commit status parameters * @param {string} options.state - The state of the status. Can be one of: pending, success, error, or failure. * @param {string} [options.target_url] - The target URL to associate with this status. * @param {string} [options.description] - A short description of the status. * @param {string} [options.context] - A string label to differentiate this status among CI systems. * @param {Requestable.callback} cb - will receive the updated commit back * @return {Promise} - the promise for the http request */ }, { key: 'updateStatus', value: function updateStatus(commitSHA, options, cb) { return this._request('POST', '/repos/' + this.__fullname + '/statuses/' + commitSHA, options, cb); } /** * Update repository information * @see https://developer.github.com/v3/repos/#edit * @param {object} options - New parameters that will be set to the repository * @param {string} options.name - Name of the repository * @param {string} [options.description] - A short description of the repository * @param {string} [options.homepage] - A URL with more information about the repository * @param {boolean} [options.private] - Either true to make the repository private, or false to make it public. * @param {boolean} [options.has_issues] - Either true to enable issues for this repository, false to disable them. * @param {boolean} [options.has_wiki] - Either true to enable the wiki for this repository, false to disable it. * @param {boolean} [options.has_downloads] - Either true to enable downloads, false to disable them. * @param {string} [options.default_branch] - Updates the default branch for this repository. * @param {Requestable.callback} cb - will receive the updated repository back * @return {Promise} - the promise for the http request */ }, { key: 'updateRepository', value: function updateRepository(options, cb) { return this._request('PATCH', '/repos/' + this.__fullname, options, cb); } /** * Get information about the repository * @see https://developer.github.com/v3/repos/#get * @param {Requestable.callback} cb - will receive the information about the repository * @return {Promise} - the promise for the http request */ }, { key: 'getDetails', value: function getDetails(cb) { return this._request('GET', '/repos/' + this.__fullname, null, cb); } /** * List the contributors to the repository * @see https://developer.github.com/v3/repos/#list-contributors * @param {Requestable.callback} cb - will receive the list of contributors * @return {Promise} - the promise for the http request */ }, { key: 'getContributors', value: function getContributors(cb) { return this._request('GET', '/repos/' + this.__fullname + '/contributors', null, cb); }
/** * List the contributor stats to the repository * @see https://developer.github.com/v3/repos/#list-contributors * @param {Requestable.callback} cb - will receive the list of contributors * @return {Promise} - the promise for the http request */ }, { key: 'getContributorStats', value: function getContributorStats(cb) { return this._request('GET', '/repos/' + this.__fullname + '/stats/contributors', null, cb); } /** * List the users who are collaborators on the repository. The currently authenticated user must have * push access to use this method * @see https://developer.github.com/v3/repos/collaborators/#list-collaborators * @param {Requestable.callback} cb - will receive the list of collaborators * @return {Promise} - the promise for the http request */ }, { key: 'getCollaborators', value: function getCollaborators(cb) { return this._request('GET', '/repos/' + this.__fullname + '/collaborators', null, cb); } /** * Check if a user is a collaborator on the repository * @see https://developer.github.com/v3/repos/collaborators/#check-if-a-user-is-a-collaborator * @param {string} username - the user to check * @param {Requestable.callback} cb - will receive true if the user is a collaborator and false if they are not * @return {Promise} - the promise for the http request {Boolean} [description] */ }, { key: 'isCollaborator', value: function isCollaborator(username, cb) { return this._request('GET', '/repos/' + this.__fullname + '/collaborators/' + username, null, cb); } /** * Get the contents of a repository * @see https://developer.github.com/v3/repos/contents/#get-contents * @param {string} ref - the ref to check * @param {string} path - the path containing the content to fetch * @param {boolean} raw - `true` if the results should be returned raw instead of GitHub's normalized format * @param {Requestable.callback} cb - will receive the fetched data * @return {Promise} - the promise for the http request */ }, { key: 'getContents', value: function getContents(ref, path, raw, cb) { path = path ? '' + encodeURI(path) : ''; return this._request('GET', '/repos/' + this.__fullname + '/contents/' + path, { ref: ref }, cb, raw); } /** * Get the README of a repository * @see https://developer.github.com/v3/repos/contents/#get-the-readme * @param {string} ref - the ref to check * @param {boolean} raw - `true` if the results should be returned raw instead of GitHub's normalized format * @param {Requestable.callback} cb - will receive the fetched data * @return {Promise} - the promise for the http request */ }, { key: 'getReadme', value: function getReadme(ref, raw, cb) { return this._request('GET', '/repos/' + this.__fullname + '/readme', { ref: ref }, cb, raw); } /** * Fork a repository * @see https://developer.github.com/v3/repos/forks/#create-a-fork * @param {Requestable.callback} cb - will receive the information about the newly created fork * @return {Promise} - the promise for the http request */ }, { key: 'fork', value: function fork(cb) { return this._request('POST', '/repos/' + this.__fullname + '/forks', null, cb); } /** * List a repository's forks * @see https://developer.github.com/v3/repos/forks/#list-forks * @param {Requestable.callback} cb - will receive the list of repositories forked from this one * @return {Promise} - the promise for the http request */ }, { key: 'listForks', value: function listForks(cb) { return this._request('GET', '/repos/' + this.__fullname + '/forks', null, cb); } /** * Create a new branch from an existing branch. * @param {string} [oldBranch=master] - the name of the existing branch * @param {string} newBranch - the name of the new branch * @param {Requestable.callback} cb - will receive the commit data for the head of the new branch * @return {Promise} - the promise for the http request */ }, { key: 'createBranch', value: function createBranch(oldBranch, newBranch, cb) { var _this3 = this; if (typeof newBranch === 'function') { cb = newBranch; newBranch = oldBranch; oldBranch = 'master'; } return this.getRef('heads/' + oldBranch).then(function (response) { var sha = response.data.object.sha; return _this3.createRef({ sha: sha, ref: 'refs/heads/' + newBranch }, cb); }); } /** * Create a new pull request * @see https://developer.github.com/v3/pulls/#create-a-pull-request * @param {Object} options - the pull request description * @param {Requestable.callback} cb - will receive the new pull request * @return {Promise} - the promise for the http request */ }, { key: 'createPullRequest', value: function createPullRequest(options, cb) { return this._request('POST', '/repos/' + this.__fullname + '/pulls', options, cb); } /** * Update a pull request * @see https://developer.github.com/v3/pulls/#update-a-pull-request * @param {number|string} number - the number of the pull request to update * @param {Object} options - the pull request description * @param {Requestable.callback} [cb] - will receive the pull request information * @return {Promise} - the promise for the http request */ }, { key: 'updatePullRequest', value: function updatePullRequest(number, options, cb) { return this._request('PATCH', '/repos/' + this.__fullname + '/pulls/' + number, options, cb); } /** * List the hooks for the repository * @see https://developer.github.com/v3/repos/hooks/#list-hooks * @param {Requestable.callback} cb - will receive the list of hooks * @return {Promise} - the promise for the http request */ }, { key: 'listHooks', value: function listHooks(cb) { return this._request('GET', '/repos/' + this.__fullname + '/hooks', null, cb); } /** * Get a hook for the repository * @see https://developer.github.com/v3/repos/hooks/#get-single-hook * @param {number} id - the id of the webook * @param {Requestable.callback} cb - will receive the details of the webook * @return {Promise} - the promise for the http request */ }, { key: 'getHook', value: function getHook(id, cb) { return this._request('GET', '/repos/' + this.__fullname + '/hooks/' + id, null, cb); } /** * Add a new hook to the repository * @see https://developer.github.com/v3/repos/hooks/#create-a-hook * @param {Object} options - the configuration describing the new hook * @param {Requestable.callback} cb - will receive the new webhook * @return {Promise} - the promise for the http request */ }, { key: 'createHook', value: function createHook(options, cb) { return this._request('POST', '/repos/' + this.__fullname + '/hooks', options, cb); } /** * Edit an existing webhook * @see https://developer.github.com/v3/repos/hooks/#edit-a-hook * @param {number} id - the id of the webhook * @param {Object} options - the new description of the webhook * @param {Requestable.callback} cb - will receive the updated webhook * @return {Promise} - the promise for the http request */ }, { key: 'updateHook', value: function updateHook(id, options, cb) { return this._request('PATCH', '/repos/' + this.__fullname + '/hooks/' + id, options, cb); } /** * Delete a webhook * @see https://developer.github.com/v3/repos/hooks/#delete-a-hook * @param {number} id - the id of the webhook to be deleted * @param {Requestable.callback} cb - will receive true if the call is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteHook', value: function deleteHook(id, cb) { return this._request('DELETE', this.__fullname + '/hooks/' + id, null, cb); } /** * List the deploy keys for the repository * @see https://developer.github.com/v3/repos/keys/#list-deploy-keys * @param {Requestable.callback} cb - will receive the list of deploy keys * @return {Promise} - the promise for the http request */ }, { key: 'listKeys', value: function listKeys(cb) { return this._request('GET', '/repos/' + this.__fullname + '/keys', null, cb); } /** * Get a deploy key for the repository * @see https://developer.github.com/v3/repos/keys/#get-a-deploy-key * @param {number} id - the id of the deploy key * @param {Requestable.callback} cb - will receive the details of the deploy key * @return {Promise} - the promise for the http request */ }, { key: 'getKey', value: function getKey(id, cb) { return this._request('GET', '/repos/' + this.__fullname + '/keys/' + id, null, cb); } /** * Add a new deploy key to the repository * @see https://developer.github.com/v3/repos/keys/#add-a-new-deploy-key * @param {Object} options - the configuration describing the new deploy key * @param {Requestable.callback} cb - will receive the new deploy key * @return {Promise} - the promise for the http request */ }, { key: 'createKey', value: function createKey(options, cb) { return this._request('POST', '/repos/' + this.__fullname + '/keys', options, cb); } /** * Delete a deploy key * @see https://developer.github.com/v3/repos/keys/#remove-a-deploy-key * @param {number} id - the id of the deploy key to be deleted * @param {Requestable.callback} cb - will receive true if the call is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteKey', value: function deleteKey(id, cb) { return this._request('DELETE', '/repos/' + this.__fullname + '/keys/' + id, null, cb); } /** * Delete a file from a branch * @see https://developer.github.com/v3/repos/contents/#delete-a-file * @param {string} branch - the branch to delete from, or the default branch if not specified * @param {string} path - the path of the file to remove * @param {Requestable.callback} cb - will receive the commit in which the delete occurred * @return {Promise} - the promise for the http request */ }, { key: 'deleteFile', value: function deleteFile(branch, path, cb) { var _this4 = this; return this.getSha(branch, path).then(function (response) { var deleteCommit = { message: 'Delete the file at \'' + path + '\'', sha: response.data.sha, branch: branch }; return _this4._request('DELETE', '/repos/' + _this4.__fullname + '/contents/' + path, deleteCommit, cb); }); } /** * Change all references in a repo from oldPath to new_path * @param {string} branch - the branch to carry out the reference change, or the default branch if not specified * @param {string} oldPath - original path * @param {string} newPath - new reference path * @param {Requestable.callback} cb - will receive the commit in which the move occurred * @return {Promise} - the promise for the http request */ }, { key: 'move', value: function move(branch, oldPath, newPath, cb) { var _this5 = this; var oldSha = void 0; return this.getRef('heads/' + branch).then(function (_ref) { var object = _ref.data.object; return _this5.getTree(object.sha + '?recursive=true'); }).then(function (_ref2) { var _ref2$data = _ref2.data, tree = _ref2$data.tree, sha = _ref2$data.sha; oldSha = sha; var newTree = tree.map(function (ref) { if (ref.path === oldPath) { ref.path = newPath; } if (ref.type === 'tree') { delete ref.sha; } return ref; }); return _this5.createTree(newTree); }).then(function (_ref3) { var tree = _ref3.data; return _this5.commit(oldSha, tree.sha, 'Renamed \'' + oldPath + '\' to \'' + newPath + '\''); }).then(function (_ref4) { var commit = _ref4.data; return _this5.updateHead('heads/' + branch, commit.sha, true, cb); }); } /** * Write a file to the repository * @see https://developer.github.com/v3/repos/contents/#update-a-file * @param {string} branch - the name of the branch * @param {string} path - the path for the file * @param {string} content - the contents of the file * @param {string} message - the commit message * @param {Object} [options] - commit options * @param {Object} [options.author] - the author of the commit * @param {Object} [options.commiter] - the committer * @param {boolean} [options.encode] - true if the content should be base64 encoded * @param {Requestable.callback} cb - will receive the new commit * @return {Promise} - the promise for the http request */ }, { key: 'writeFile', value: function writeFile(branch, path, content, message, options, cb) { var _this6 = this; if (typeof options === 'function') { cb = options; options = {}; } var filePath = path ? encodeURI(path) : ''; var shouldEncode = options.encode !== false; var commit = { branch: branch, message: message, author: options.author, committer: options.committer, content: shouldEncode ? _jsBase.Base64.encode(content) : content }; return this.getSha(branch, filePath).then(function (response) { commit.sha = response.data.sha; return _this6._request('PUT', '/repos/' + _this6.__fullname + '/contents/' + filePath, commit, cb); }, function () { return _this6._request('PUT', '/repos/' + _this6.__fullname + '/contents/' + filePath, commit, cb); }); } /** * Check if a repository is starred by you * @see https://developer.github.com/v3/activity/starring/#check-if-you-are-starring-a-repository * @param {Requestable.callback} cb - will receive true if the repository is starred and false if the repository * is not starred * @return {Promise} - the promise for the http request {Boolean} [description] */ }, { key: 'isStarred', value: function isStarred(cb) { return this._request204or404('/user/starred/' + this.__fullname, null, cb); } /** * Star a repository * @see https://developer.github.com/v3/activity/starring/#star-a-repository * @param {Requestable.callback} cb - will receive true if the repository is starred * @return {Promise} - the promise for the http request */ }, { key: 'star', value: function star(cb) { return this._request('PUT', '/user/starred/' + this.__fullname, null, cb); } /** * Unstar a repository * @see https://developer.github.com/v3/activity/starring/#unstar-a-repository * @param {Requestable.callback} cb - will receive true if the repository is unstarred * @return {Promise} - the promise for the http request */ }, { key: 'unstar', value: function unstar(cb) { return this._request('DELETE', '/user/starred/' + this.__fullname, null, cb); } /** * Create a new release * @see https://developer.github.com/v3/repos/releases/#create-a-release * @param {Object} options - the description of the release * @param {Requestable.callback} cb - will receive the newly created release * @return {Promise} - the promise for the http request */ }, { key: 'createRelease', value: function createRelease(options, cb) { return this._request('POST', '/repos/' + this.__fullname + '/releases', options, cb); } /** * Edit a release * @see https://developer.github.com/v3/repos/releases/#edit-a-release * @param {string} id - the id of the release * @param {Object} options - the description of the release * @param {Requestable.callback} cb - will receive the modified release * @return {Promise} - the promise for the http request */ }, { key: 'updateRelease', value: function updateRelease(id, options, cb) { return this._request('PATCH', '/repos/' + this.__fullname + '/releases/' + id, options, cb); } /** * Get information about all releases * @see https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository * @param {Requestable.callback} cb - will receive the release information * @return {Promise} - the promise for the http request */ }, { key: 'listReleases', value: function listReleases(cb) { return this._request('GET', '/repos/' + this.__fullname + '/releases', null, cb); } /** * Get information about a release * @see https://developer.github.com/v3/repos/releases/#get-a-single-release * @param {string} id - the id of the release * @param {Requestable.callback} cb - will receive the release information * @return {Promise} - the promise for the http request */ }, { key: 'getRelease', value: function getRelease(id, cb) { return this._request('GET', '/repos/' + this.__fullname + '/releases/' + id, null, cb); } /** * Delete a release * @see https://developer.github.com/v3/repos/releases/#delete-a-release * @param {string} id - the release to be deleted * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteRelease', value: function deleteRelease(id, cb) { return this._request('DELETE', '/repos/' + this.__fullname + '/releases/' + id, null, cb); } /** * Merge a pull request * @see https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-button * @param {number|string} number - the number of the pull request to merge * @param {Object} options - the merge options for the pull request * @param {Requestable.callback} [cb] - will receive the merge information if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'mergePullRequest', value: function mergePullRequest(number, options, cb) { return this._request('PUT', '/repos/' + this.__fullname + '/pulls/' + number + '/merge', options, cb); } /** * Get information about all projects * @see https://developer.github.com/v3/projects/#list-repository-projects * @param {Requestable.callback} [cb] - will receive the list of projects * @return {Promise} - the promise for the http request */ }, { key: 'listProjects', value: function listProjects(cb) { return this._requestAllPages('/repos/' + this.__fullname + '/projects', { AcceptHeader: 'inertia-preview' }, cb); } /** * Create a new project * @see https://developer.github.com/v3/projects/#create-a-repository-project * @param {Object} options - the description of the project * @param {Requestable.callback} cb - will receive the newly created project * @return {Promise} - the promise for the http request */ }, { key: 'createProject', value: function createProject(options, cb) { options = options || {}; options.AcceptHeader = 'inertia-preview'; return this._request('POST', '/repos/' + this.__fullname + '/projects', options, cb); } }]); return Repository; }(_Requestable3.default); module.exports = Repository; }).call(this,require("buffer").Buffer)(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GitHub = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * A Gist can retrieve and modify gists. */ var Gist = function (_Requestable) { _inherits(Gist, _Requestable); /** * Create a Gist. * @param {string} id - the id of the gist (not required when creating a gist) * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Gist(id, auth, apiBase) { _classCallCheck(this, Gist); var _this = _possibleConstructorReturn(this, (Gist.__proto__ || Object.getPrototypeOf(Gist)).call(this, auth, apiBase)); _this.__id = id; return _this; } /** * Fetch a gist. * @see https://developer.github.com/v3/gists/#get-a-single-gist * @param {Requestable.callback} [cb] - will receive the gist * @return {Promise} - the Promise for the http request */ _createClass(Gist, [{ key: 'read', value: function read(cb) { return this._request('GET', '/gists/' + this.__id, null, cb); } /** * Create a new gist. * @see https://developer.github.com/v3/gists/#create-a-gist * @param {Object} gist - the data for the new gist * @param {Requestable.callback} [cb] - will receive the new gist upon creation * @return {Promise} - the Promise for the http request */ }, { key: 'create', value: function create(gist, cb) { var _this2 = this; return this._request('POST', '/gists', gist, cb).then(function (response) { _this2.__id = response.data.id; return response; }); } /** * Delete a gist. * @see https://developer.github.com/v3/gists/#delete-a-gist * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'delete', value: function _delete(cb) { return this._request('DELETE', '/gists/' + this.__id, null, cb); } /** * Fork a gist. * @see https://developer.github.com/v3/gists/#fork-a-gist * @param {Requestable.callback} [cb] - the function that will receive the gist * @return {Promise} - the Promise for the http request */ }, { key: 'fork', value: function fork(cb) { return this._request('POST', '/gists/' + this.__id + '/forks', null, cb); } /** * Update a gist. * @see https://developer.github.com/v3/gists/#edit-a-gist * @param {Object} gist - the new data for the gist * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'update', value: function update(gist, cb) { return this._request('PATCH', '/gists/' + this.__id, gist, cb); } /** * Star a gist. * @see https://developer.github.com/v3/gists/#star-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'star', value: function star(cb) { return this._request('PUT', '/gists/' + this.__id + '/star', null, cb); } /** * Unstar a gist. * @see https://developer.github.com/v3/gists/#unstar-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'unstar', value: function unstar(cb) { return this._request('DELETE', '/gists/' + this.__id + '/star', null, cb); } /** * Check if a gist is starred by the user. * @see https://developer.github.com/v3/gists/#check-if-a-gist-is-starred * @param {Requestable.callback} [cb] - will receive true if the gist is starred and false if the gist is not starred * @return {Promise} - the Promise for the http request */ }, { key: 'isStarred', value: function isStarred(cb) { return this._request204or404('/gists/' + this.__id + '/star', null, cb); } /** * List the gist's comments * @see https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist * @param {Requestable.callback} [cb] - will receive the array of comments * @return {Promise} - the promise for the http request */ }, { key: 'listComments', value: function listComments(cb) { return this._requestAllPages('/gists/' + this.__id + '/comments', null, cb); } /** * Fetch one of the gist's comments * @see https://developer.github.com/v3/gists/comments/#get-a-single-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the Promise for the http request */ }, { key: 'getComment', value: function getComment(comment, cb) { return this._request('GET', '/gists/' + this.__id + '/comments/' + comment, null, cb); } /** * Comment on a gist * @see https://developer.github.com/v3/gists/comments/#create-a-comment * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'createComment', value: function createComment(comment, cb) { return this._request('POST', '/gists/' + this.__id + '/comments', { body: comment }, cb); } /** * Edit a comment on the gist * @see https://developer.github.com/v3/gists/comments/#edit-a-comment * @param {number} comment - the id of the comment * @param {string} body - the new comment * @param {Requestable.callback} [cb] - will receive the modified comment * @return {Promise} - the promise for the http request */ }, { key: 'editComment', value: function editComment(comment, body, cb) { return this._request('PATCH', '/gists/' + this.__id + '/comments/' + comment, { body: body }, cb); } /** * Delete a comment on the gist. * @see https://developer.github.com/v3/gists/comments/#delete-a-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'deleteComment', value: function deleteComment(comment, cb) { return this._request('DELETE', '/gists/' + this.__id + '/comments/' + comment, null, cb); } }]); return Gist; }(_Requestable3.default); module.exports = Gist;
