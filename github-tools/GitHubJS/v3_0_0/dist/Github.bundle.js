(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GitHub = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * A Gist can retrieve and modify gists. */ var Gist = function (_Requestable) { _inherits(Gist, _Requestable); /** * Create a Gist. * @param {string} id - the id of the gist (not required when creating a gist) * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Gist(id, auth, apiBase) { _classCallCheck(this, Gist); var _this = _possibleConstructorReturn(this, (Gist.__proto__ || Object.getPrototypeOf(Gist)).call(this, auth, apiBase)); _this.__id = id; return _this; } /** * Fetch a gist. * @see https://developer.github.com/v3/gists/#get-a-single-gist * @param {Requestable.callback} [cb] - will receive the gist * @return {Promise} - the Promise for the http request */ _createClass(Gist, [{ key: 'read', value: function read(cb) { return this._request('GET', '/gists/' + this.__id, null, cb); } /** * Create a new gist. * @see https://developer.github.com/v3/gists/#create-a-gist * @param {Object} gist - the data for the new gist * @param {Requestable.callback} [cb] - will receive the new gist upon creation * @return {Promise} - the Promise for the http request */ }, { key: 'create', value: function create(gist, cb) { var _this2 = this; return this._request('POST', '/gists', gist, cb).then(function (response) { _this2.__id = response.data.id; return response; }); } /** * Delete a gist. * @see https://developer.github.com/v3/gists/#delete-a-gist * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'delete', value: function _delete(cb) { return this._request('DELETE', '/gists/' + this.__id, null, cb); } /** * Fork a gist. * @see https://developer.github.com/v3/gists/#fork-a-gist * @param {Requestable.callback} [cb] - the function that will receive the gist * @return {Promise} - the Promise for the http request */ }, { key: 'fork', value: function fork(cb) { return this._request('POST', '/gists/' + this.__id + '/forks', null, cb); } /** * Update a gist. * @see https://developer.github.com/v3/gists/#edit-a-gist * @param {Object} gist - the new data for the gist * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'update', value: function update(gist, cb) { return this._request('PATCH', '/gists/' + this.__id, gist, cb); } /** * Star a gist. * @see https://developer.github.com/v3/gists/#star-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'star', value: function star(cb) { return this._request('PUT', '/gists/' + this.__id + '/star', null, cb); } /** * Unstar a gist. * @see https://developer.github.com/v3/gists/#unstar-a-gist * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the Promise for the http request */ }, { key: 'unstar', value: function unstar(cb) { return this._request('DELETE', '/gists/' + this.__id + '/star', null, cb); } /** * Check if a gist is starred by the user. * @see https://developer.github.com/v3/gists/#check-if-a-gist-is-starred * @param {Requestable.callback} [cb] - will receive true if the gist is starred and false if the gist is not starred * @return {Promise} - the Promise for the http request */ }, { key: 'isStarred', value: function isStarred(cb) { return this._request204or404('/gists/' + this.__id + '/star', null, cb); } /** * List the gist's comments * @see https://developer.github.com/v3/gists/comments/#list-comments-on-a-gist * @param {Requestable.callback} [cb] - will receive the array of comments * @return {Promise} - the promise for the http request */ }, { key: 'listComments', value: function listComments(cb) { return this._requestAllPages('/gists/' + this.__id + '/comments', null, cb); } /** * Fetch one of the gist's comments * @see https://developer.github.com/v3/gists/comments/#get-a-single-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the Promise for the http request */ }, { key: 'getComment', value: function getComment(comment, cb) { return this._request('GET', '/gists/' + this.__id + '/comments/' + comment, null, cb); } /** * Comment on a gist * @see https://developer.github.com/v3/gists/comments/#create-a-comment * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - the function that receives the API result * @return {Promise} - the Promise for the http request */ }, { key: 'createComment', value: function createComment(comment, cb) { return this._request('POST', '/gists/' + this.__id + '/comments', { body: comment }, cb); } /** * Edit a comment on the gist * @see https://developer.github.com/v3/gists/comments/#edit-a-comment * @param {number} comment - the id of the comment * @param {string} body - the new comment * @param {Requestable.callback} [cb] - will receive the modified comment * @return {Promise} - the promise for the http request */ }, { key: 'editComment', value: function editComment(comment, body, cb) { return this._request('PATCH', '/gists/' + this.__id + '/comments/' + comment, { body: body }, cb); } /** * Delete a comment on the gist. * @see https://developer.github.com/v3/gists/comments/#delete-a-comment * @param {number} comment - the id of the comment * @param {Requestable.callback} [cb] - will receive true if the request succeeds * @return {Promise} - the Promise for the http request */ }, { key: 'deleteComment', value: function deleteComment(comment, cb) { return this._request('DELETE', '/gists/' + this.__id + '/comments/' + comment, null, cb); } }]); return Gist; }(_Requestable3.default); 


module.exports = Gist; 

 },{"./Requestable":9}],2:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /* eslint valid-jsdoc: ["error", {"requireReturnDescription": false}] */ var _Gist = require('./Gist'); var _Gist2 = _interopRequireDefault(_Gist); var _User = require('./User'); var _User2 = _interopRequireDefault(_User); var _Issue = require('./Issue'); var _Issue2 = _interopRequireDefault(_Issue); var _Search = require('./Search'); var _Search2 = _interopRequireDefault(_Search); var _RateLimit = require('./RateLimit'); var _RateLimit2 = _interopRequireDefault(_RateLimit); var _Repository = require('./Repository'); var _Repository2 = _interopRequireDefault(_Repository); var _Organization = require('./Organization'); var _Organization2 = _interopRequireDefault(_Organization); var _Team = require('./Team'); var _Team2 = _interopRequireDefault(_Team); var _Markdown = require('./Markdown'); var _Markdown2 = _interopRequireDefault(_Markdown); var _Project = require('./Project'); var _Project2 = _interopRequireDefault(_Project); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /** * GitHub encapsulates the functionality to create various API wrapper objects. */ var GitHub = function () { /** * Create a new GitHub. * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is * not provided requests will be made unauthenticated * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function GitHub(auth) { var apiBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'https://api.github.com'; _classCallCheck(this, GitHub); this.__apiBase = apiBase; this.__auth = auth || {}; } /** * Create a new Gist wrapper * @param {number} [id] - the id for the gist, leave undefined when creating a new gist * @return {Gist} */ _createClass(GitHub, [{ key: 'getGist', value: function getGist(id) { return new _Gist2.default(id, this.__auth, this.__apiBase); } /** * Create a new User wrapper * @param {string} [user] - the name of the user to get information about * leave undefined for the authenticated user * @return {User} */ }, { key: 'getUser', value: function getUser(user) { return new _User2.default(user, this.__auth, this.__apiBase); } /** * Create a new Organization wrapper * @param {string} organization - the name of the organization * @return {Organization} */ }, { key: 'getOrganization', value: function getOrganization(organization) { return new _Organization2.default(organization, this.__auth, this.__apiBase); } /** * create a new Team wrapper * @param {string} teamId - the name of the team * @return {team} */ }, { key: 'getTeam', value: function getTeam(teamId) { return new _Team2.default(teamId, this.__auth, this.__apiBase); } /** * Create a new Repository wrapper * @param {string} user - the user who owns the respository * @param {string} repo - the name of the repository * @return {Repository} */ }, { key: 'getRepo', value: function getRepo(user, repo) { return new _Repository2.default(this._getFullName(user, repo), this.__auth, this.__apiBase); } /** * Create a new Issue wrapper * @param {string} user - the user who owns the respository * @param {string} repo - the name of the repository * @return {Issue} */ }, { key: 'getIssues', value: function getIssues(user, repo) { return new _Issue2.default(this._getFullName(user, repo), this.__auth, this.__apiBase); } /** * Create a new Search wrapper * @param {string} query - the query to search for * @return {Search} */ }, { key: 'search', value: function search(query) { return new _Search2.default(query, this.__auth, this.__apiBase); } /** * Create a new RateLimit wrapper * @return {RateLimit} */ }, { key: 'getRateLimit', value: function getRateLimit() { return new _RateLimit2.default(this.__auth, this.__apiBase); } /** * Create a new Markdown wrapper * @return {Markdown} */ }, { key: 'getMarkdown', value: function getMarkdown() { return new _Markdown2.default(this.__auth, this.__apiBase); } /** * Create a new Project wrapper * @param {string} id - the id of the project * @return {Markdown} */ }, { key: 'getProject', value: function getProject(id) { return new _Project2.default(id, this.__auth, this.__apiBase); } /** * Computes the full repository name * @param {string} user - the username (or the full name) * @param {string} repo - the repository name, must not be passed if `user` is the full name * @return {string} the repository's full name */ }, { key: '_getFullName', value: function _getFullName(user, repo) { var fullname = user; if (repo) { fullname = user + '/' + repo; } return fullname; } }]); return GitHub; }(); module.exports = GitHub; },{"./Gist":1,"./Issue":3,"./Markdown":4,"./Organization":5,"./Project":6,"./RateLimit":7,"./Repository":8,"./Search":10,"./Team":11,"./User":12}],3:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Issue wraps the functionality to get issues for repositories */ var Issue = function (_Requestable) { _inherits(Issue, _Requestable); /** * Create a new Issue * @param {string} repository - the full name of the repository (`:user/:repo`) to get issues for * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Issue(repository, auth, apiBase) { _classCallCheck(this, Issue); var _this = _possibleConstructorReturn(this, (Issue.__proto__ || Object.getPrototypeOf(Issue)).call(this, auth, apiBase)); _this.__repository = repository; return _this; } /** * Create a new issue * @see https://developer.github.com/v3/issues/#create-an-issue * @param {Object} issueData - the issue to create * @param {Requestable.callback} [cb] - will receive the created issue * @return {Promise} - the promise for the http request */ _createClass(Issue, [{ key: 'createIssue', value: function createIssue(issueData, cb) { return this._request('POST', '/repos/' + this.__repository + '/issues', issueData, cb); } /** * List the issues for the repository * @see https://developer.github.com/v3/issues/#list-issues-for-a-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of issues * @return {Promise} - the promise for the http request */ }, { key: 'listIssues', value: function listIssues(options, cb) { return this._requestAllPages('/repos/' + this.__repository + '/issues', options, cb); } /** * List the events for an issue * @see https://developer.github.com/v3/issues/events/#list-events-for-an-issue * @param {number} issue - the issue to get events for * @param {Requestable.callback} [cb] - will receive the list of events * @return {Promise} - the promise for the http request */ }, { key: 'listIssueEvents', value: function listIssueEvents(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/events', null, cb); } /** * List comments on an issue * @see https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue * @param {number} issue - the id of the issue to get comments from * @param {Requestable.callback} [cb] - will receive the comments * @return {Promise} - the promise for the http request */ }, { key: 'listIssueComments', value: function listIssueComments(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue + '/comments', null, cb); } /** * Get a single comment on an issue * @see https://developer.github.com/v3/issues/comments/#get-a-single-comment * @param {number} id - the comment id to get * @param {Requestable.callback} [cb] - will receive the comment * @return {Promise} - the promise for the http request */ }, { key: 'getIssueComment', value: function getIssueComment(id, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb); } /** * Comment on an issue * @see https://developer.github.com/v3/issues/comments/#create-a-comment * @param {number} issue - the id of the issue to comment on * @param {string} comment - the comment to add * @param {Requestable.callback} [cb] - will receive the created comment * @return {Promise} - the promise for the http request */ }, { key: 'createIssueComment', value: function createIssueComment(issue, comment, cb) { return this._request('POST', '/repos/' + this.__repository + '/issues/' + issue + '/comments', { body: comment }, cb); } /** * Edit a comment on an issue * @see https://developer.github.com/v3/issues/comments/#edit-a-comment * @param {number} id - the comment id to edit * @param {string} comment - the comment to edit * @param {Requestable.callback} [cb] - will receive the edited comment * @return {Promise} - the promise for the http request */ }, { key: 'editIssueComment', value: function editIssueComment(id, comment, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/issues/comments/' + id, { body: comment }, cb); } /** * Delete a comment on an issue * @see https://developer.github.com/v3/issues/comments/#delete-a-comment * @param {number} id - the comment id to delete * @param {Requestable.callback} [cb] - will receive true if the request is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteIssueComment', value: function deleteIssueComment(id, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/issues/comments/' + id, null, cb); } /** * Edit an issue * @see https://developer.github.com/v3/issues/#edit-an-issue * @param {number} issue - the issue number to edit * @param {Object} issueData - the new issue data * @param {Requestable.callback} [cb] - will receive the modified issue * @return {Promise} - the promise for the http request */ }, { key: 'editIssue', value: function editIssue(issue, issueData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/issues/' + issue, issueData, cb); } /** * Get a particular issue * @see https://developer.github.com/v3/issues/#get-a-single-issue * @param {number} issue - the issue number to fetch * @param {Requestable.callback} [cb] - will receive the issue * @return {Promise} - the promise for the http request */ }, { key: 'getIssue', value: function getIssue(issue, cb) { return this._request('GET', '/repos/' + this.__repository + '/issues/' + issue, null, cb); } /** * List the milestones for the repository * @see https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of milestones * @return {Promise} - the promise for the http request */ }, { key: 'listMilestones', value: function listMilestones(options, cb) { return this._request('GET', '/repos/' + this.__repository + '/milestones', options, cb); } /** * Get a milestone * @see https://developer.github.com/v3/issues/milestones/#get-a-single-milestone * @param {string} milestone - the id of the milestone to fetch * @param {Requestable.callback} [cb] - will receive the milestone * @return {Promise} - the promise for the http request */ }, { key: 'getMilestone', value: function getMilestone(milestone, cb) { return this._request('GET', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb); } /** * Create a new milestone * @see https://developer.github.com/v3/issues/milestones/#create-a-milestone * @param {Object} milestoneData - the milestone definition * @param {Requestable.callback} [cb] - will receive the milestone * @return {Promise} - the promise for the http request */ }, { key: 'createMilestone', value: function createMilestone(milestoneData, cb) { return this._request('POST', '/repos/' + this.__repository + '/milestones', milestoneData, cb); } /** * Edit a milestone * @see https://developer.github.com/v3/issues/milestones/#update-a-milestone * @param {string} milestone - the id of the milestone to edit * @param {Object} milestoneData - the updates to make to the milestone * @param {Requestable.callback} [cb] - will receive the updated milestone * @return {Promise} - the promise for the http request */ }, { key: 'editMilestone', value: function editMilestone(milestone, milestoneData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/milestones/' + milestone, milestoneData, cb); } /** * Delete a milestone (this is distinct from closing a milestone) * @see https://developer.github.com/v3/issues/milestones/#delete-a-milestone * @param {string} milestone - the id of the milestone to delete * @param {Requestable.callback} [cb] - will receive the status * @return {Promise} - the promise for the http request */ }, { key: 'deleteMilestone', value: function deleteMilestone(milestone, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/milestones/' + milestone, null, cb); } /** * Create a new label * @see https://developer.github.com/v3/issues/labels/#create-a-label * @param {Object} labelData - the label definition * @param {Requestable.callback} [cb] - will receive the object representing the label * @return {Promise} - the promise for the http request */ }, { key: 'createLabel', value: function createLabel(labelData, cb) { return this._request('POST', '/repos/' + this.__repository + '/labels', labelData, cb); } /** * List the labels for the repository * @see https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository * @param {Object} options - filtering options * @param {Requestable.callback} [cb] - will receive the array of labels * @return {Promise} - the promise for the http request */ }, { key: 'listLabels', value: function listLabels(options, cb) { return this._request('GET', '/repos/' + this.__repository + '/labels', options, cb); } /** * Get a label * @see https://developer.github.com/v3/issues/labels/#get-a-single-label * @param {string} label - the name of the label to fetch * @param {Requestable.callback} [cb] - will receive the label * @return {Promise} - the promise for the http request */ }, { key: 'getLabel', value: function getLabel(label, cb) { return this._request('GET', '/repos/' + this.__repository + '/labels/' + label, null, cb); } /** * Edit a label * @see https://developer.github.com/v3/issues/labels/#update-a-label * @param {string} label - the name of the label to edit * @param {Object} labelData - the updates to make to the label * @param {Requestable.callback} [cb] - will receive the updated label * @return {Promise} - the promise for the http request */ }, { key: 'editLabel', value: function editLabel(label, labelData, cb) { return this._request('PATCH', '/repos/' + this.__repository + '/labels/' + label, labelData, cb); } /** * Delete a label * @see https://developer.github.com/v3/issues/labels/#delete-a-label * @param {string} label - the name of the label to delete * @param {Requestable.callback} [cb] - will receive the status * @return {Promise} - the promise for the http request */ }, { key: 'deleteLabel', value: function deleteLabel(label, cb) { return this._request('DELETE', '/repos/' + this.__repository + '/labels/' + label, null, cb); } }]); return Issue; }(_Requestable3.default);
 
 
 
module.exports = Issue; 



 
 
 },{"./Requestable":9}],4:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Renders html from Markdown text */ var Markdown = function (_Requestable) { _inherits(Markdown, _Requestable); /** * construct a Markdown * @param {Requestable.auth} auth - the credentials to authenticate to GitHub * @param {string} [apiBase] - the base Github API URL * @return {Promise} - the promise for the http request */ function Markdown(auth, apiBase) { _classCallCheck(this, Markdown); return _possibleConstructorReturn(this, (Markdown.__proto__ || Object.getPrototypeOf(Markdown)).call(this, auth, apiBase)); } /** * Render html from Markdown text. * @see https://developer.github.com/v3/markdown/#render-an-arbitrary-markdown-document * @param {Object} options - conversion options * @param {string} [options.text] - the markdown text to convert * @param {string} [options.mode=markdown] - can be either `markdown` or `gfm` * @param {string} [options.context] - repository name if mode is gfm * @param {Requestable.callback} [cb] - will receive the converted html * @return {Promise} - the promise for the http request */ _createClass(Markdown, [{ key: 'render', value: function render(options, cb) { return this._request('POST', '/markdown', options, cb); } }]); return Markdown; }(_Requestable3.default); module.exports = Markdown; },{"./Requestable":9}],5:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Organization encapsulates the functionality to create repositories in organizations */ var Organization = function (_Requestable) { _inherits(Organization, _Requestable); /** * Create a new Organization * @param {string} organization - the name of the organization * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Organization(organization, auth, apiBase) { _classCallCheck(this, Organization); var _this = _possibleConstructorReturn(this, (Organization.__proto__ || Object.getPrototypeOf(Organization)).call(this, auth, apiBase)); _this.__name = organization; return _this; } /** * Create a repository in an organization * @see https://developer.github.com/v3/repos/#create * @param {Object} options - the repository definition * @param {Requestable.callback} [cb] - will receive the created repository * @return {Promise} - the promise for the http request */ _createClass(Organization, [{ key: 'createRepo', value: function createRepo(options, cb) { return this._request('POST', '/orgs/' + this.__name + '/repos', options, cb); } /** * List the repositories in an organization * @see https://developer.github.com/v3/repos/#list-organization-repositories * @param {Requestable.callback} [cb] - will receive the list of repositories * @return {Promise} - the promise for the http request */ }, { key: 'getRepos', value: function getRepos(cb) { var requestOptions = this._getOptionsWithDefaults({ direction: 'desc' }); return this._requestAllPages('/orgs/' + this.__name + '/repos', requestOptions, cb); } /** * Query if the user is a member or not * @param {string} username - the user in question * @param {Requestable.callback} [cb] - will receive true if the user is a member * @return {Promise} - the promise for the http request */ }, { key: 'isMember', value: function isMember(username, cb) { return this._request204or404('/orgs/' + this.__name + '/members/' + username, null, cb); } /** * List the users who are members of the company * @see https://developer.github.com/v3/orgs/members/#members-list * @param {object} options - filtering options * @param {string} [options.filter=all] - can be either `2fa_disabled` or `all` * @param {string} [options.role=all] - can be one of: `all`, `admin`, or `member` * @param {Requestable.callback} [cb] - will receive the list of users * @return {Promise} - the promise for the http request */ }, { key: 'listMembers', value: function listMembers(options, cb) { return this._request('GET', '/orgs/' + this.__name + '/members', options, cb); } /** * List the Teams in the Organization * @see https://developer.github.com/v3/orgs/teams/#list-teams * @param {Requestable.callback} [cb] - will receive the list of teams * @return {Promise} - the promise for the http request */ }, { key: 'getTeams', value: function getTeams(cb) { return this._requestAllPages('/orgs/' + this.__name + '/teams', undefined, cb); } /** * Create a team * @see https://developer.github.com/v3/orgs/teams/#create-team * @param {object} options - Team creation parameters * @param {string} options.name - The name of the team * @param {string} [options.description] - Team description * @param {string} [options.repo_names] - Repos to add the team to * @param {string} [options.privacy=secret] - The level of privacy the team should have. Can be either one * of: `secret`, or `closed` * @param {Requestable.callback} [cb] - will receive the created team * @return {Promise} - the promise for the http request */ }, { key: 'createTeam', value: function createTeam(options, cb) { return this._request('POST', '/orgs/' + this.__name + '/teams', options, cb); } /** * Get information about all projects * @see https://developer.github.com/v3/projects/#list-organization-projects * @param {Requestable.callback} [cb] - will receive the list of projects * @return {Promise} - the promise for the http request */ }, { key: 'listProjects', value: function listProjects(cb) { return this._requestAllPages('/orgs/' + this.__name + '/projects', { AcceptHeader: 'inertia-preview' }, cb); } /** * Create a new project * @see https://developer.github.com/v3/repos/projects/#create-a-project * @param {Object} options - the description of the project * @param {Requestable.callback} cb - will receive the newly created project * @return {Promise} - the promise for the http request */ }, { key: 'createProject', value: function createProject(options, cb) { options = options || {}; options.AcceptHeader = 'inertia-preview'; return this._request('POST', '/orgs/' + this.__name + '/projects', options, cb); } }]); return Organization; }(_Requestable3.default); module.exports = Organization; },{"./Requestable":9}],6:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * Project encapsulates the functionality to create, query, and modify cards and columns. */ var Project = function (_Requestable) { _inherits(Project, _Requestable); /** * Create a Project. * @param {string} id - the id of the project * @param {Requestable.auth} [auth] - information required to authenticate to Github * @param {string} [apiBase=https://api.github.com] - the base Github API URL */ function Project(id, auth, apiBase) { _classCallCheck(this, Project); var _this = _possibleConstructorReturn(this, (Project.__proto__ || Object.getPrototypeOf(Project)).call(this, auth, apiBase, 'inertia-preview')); _this.__id = id; return _this; } /** * Get information about a project * @see https://developer.github.com/v3/projects/#get-a-project * @param {Requestable.callback} cb - will receive the project information * @return {Promise} - the promise for the http request */ _createClass(Project, [{ key: 'getProject', value: function getProject(cb) { return this._request('GET', '/projects/' + this.__id, null, cb); } /** * Edit a project * @see https://developer.github.com/v3/projects/#update-a-project * @param {Object} options - the description of the project * @param {Requestable.callback} cb - will receive the modified project * @return {Promise} - the promise for the http request */ }, { key: 'updateProject', value: function updateProject(options, cb) { return this._request('PATCH', '/projects/' + this.__id, options, cb); } /** * Delete a project * @see https://developer.github.com/v3/projects/#delete-a-project * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteProject', value: function deleteProject(cb) { return this._request('DELETE', '/projects/' + this.__id, null, cb); } /** * Get information about all columns of a project * @see https://developer.github.com/v3/projects/columns/#list-project-columns * @param {Requestable.callback} [cb] - will receive the list of columns * @return {Promise} - the promise for the http request */ }, { key: 'listProjectColumns', value: function listProjectColumns(cb) { return this._requestAllPages('/projects/' + this.__id + '/columns', null, cb); } /** * Get information about a column * @see https://developer.github.com/v3/projects/columns/#get-a-project-column * @param {string} colId - the id of the column * @param {Requestable.callback} cb - will receive the column information * @return {Promise} - the promise for the http request */ }, { key: 'getProjectColumn', value: function getProjectColumn(colId, cb) { return this._request('GET', '/projects/columns/' + colId, null, cb); } /** * Create a new column * @see https://developer.github.com/v3/projects/columns/#create-a-project-column * @param {Object} options - the description of the column * @param {Requestable.callback} cb - will receive the newly created column * @return {Promise} - the promise for the http request */ }, { key: 'createProjectColumn', value: function createProjectColumn(options, cb) { return this._request('POST', '/projects/' + this.__id + '/columns', options, cb); } /** * Edit a column * @see https://developer.github.com/v3/projects/columns/#update-a-project-column * @param {string} colId - the column id * @param {Object} options - the description of the column * @param {Requestable.callback} cb - will receive the modified column * @return {Promise} - the promise for the http request */ }, { key: 'updateProjectColumn', value: function updateProjectColumn(colId, options, cb) { return this._request('PATCH', '/projects/columns/' + colId, options, cb); } /** * Delete a column * @see https://developer.github.com/v3/projects/columns/#delete-a-project-column * @param {string} colId - the column to be deleted * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteProjectColumn', value: function deleteProjectColumn(colId, cb) { return this._request('DELETE', '/projects/columns/' + colId, null, cb); } /** * Move a column * @see https://developer.github.com/v3/projects/columns/#move-a-project-column * @param {string} colId - the column to be moved * @param {string} position - can be one of first, last, or after:<column-id>, * where <column-id> is the id value of a column in the same project. * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'moveProjectColumn', value: function moveProjectColumn(colId, position, cb) { return this._request('POST', '/projects/columns/' + colId + '/moves', { position: position }, cb); } /** * Get information about all cards of a project * @see https://developer.github.com/v3/projects/cards/#list-project-cards * @param {Requestable.callback} [cb] - will receive the list of cards * @return {Promise} - the promise for the http request */ }, { key: 'listProjectCards', value: function listProjectCards(cb) { var _this2 = this; return this.listProjectColumns().then(function (_ref) { var data = _ref.data; return Promise.all(data.map(function (column) { return _this2._requestAllPages('/projects/columns/' + column.id + '/cards', null); })); }).then(function (cardsInColumns) { var cards = cardsInColumns.reduce(function (prev, _ref2) { var data = _ref2.data; prev.push.apply(prev, _toConsumableArray(data)); return prev; }, []); if (cb) { cb(null, cards); } return cards; }).catch(function (err) { if (cb) { cb(err); return; } throw err; }); } /** * Get information about all cards of a column * @see https://developer.github.com/v3/projects/cards/#list-project-cards * @param {string} colId - the id of the column * @param {Requestable.callback} [cb] - will receive the list of cards * @return {Promise} - the promise for the http request */ }, { key: 'listColumnCards', value: function listColumnCards(colId, cb) { return this._requestAllPages('/projects/columns/' + colId + '/cards', null, cb); } /** * Get information about a card * @see https://developer.github.com/v3/projects/cards/#get-a-project-card * @param {string} cardId - the id of the card * @param {Requestable.callback} cb - will receive the card information * @return {Promise} - the promise for the http request */ }, { key: 'getProjectCard', value: function getProjectCard(cardId, cb) { return this._request('GET', '/projects/columns/cards/' + cardId, null, cb); } /** * Create a new card * @see https://developer.github.com/v3/projects/cards/#create-a-project-card * @param {string} colId - the column id * @param {Object} options - the description of the card * @param {Requestable.callback} cb - will receive the newly created card * @return {Promise} - the promise for the http request */ }, { key: 'createProjectCard', value: function createProjectCard(colId, options, cb) { return this._request('POST', '/projects/columns/' + colId + '/cards', options, cb); } /** * Edit a card * @see https://developer.github.com/v3/projects/cards/#update-a-project-card * @param {string} cardId - the card id * @param {Object} options - the description of the card * @param {Requestable.callback} cb - will receive the modified card * @return {Promise} - the promise for the http request */ }, { key: 'updateProjectCard', value: function updateProjectCard(cardId, options, cb) { return this._request('PATCH', '/projects/columns/cards/' + cardId, options, cb); } /** * Delete a card * @see https://developer.github.com/v3/projects/cards/#delete-a-project-card * @param {string} cardId - the card to be deleted * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'deleteProjectCard', value: function deleteProjectCard(cardId, cb) { return this._request('DELETE', '/projects/columns/cards/' + cardId, null, cb); } /** * Move a card * @see https://developer.github.com/v3/projects/cards/#move-a-project-card * @param {string} cardId - the card to be moved * @param {string} position - can be one of top, bottom, or after:<card-id>, * where <card-id> is the id value of a card in the same project. * @param {string} colId - the id value of a column in the same project. * @param {Requestable.callback} cb - will receive true if the operation is successful * @return {Promise} - the promise for the http request */ }, { key: 'moveProjectCard', value: function moveProjectCard(cardId, position, colId, cb) { return this._request('POST', '/projects/columns/cards/' + cardId + '/moves', { position: position, column_id: colId }, // eslint-disable-line camelcase cb); } }]); return Project; }(_Requestable3.default); module.exports = Project; },{"./Requestable":9}],7:[function(require,module,exports){ 'use strict'; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _Requestable2 = require('./Requestable'); var _Requestable3 = _interopRequireDefault(_Requestable2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * @file * @copyright 2013 Michael Aufreiter (Development Seed) and 2016 Yahoo Inc. * @license Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}. * Github.js is freely distributable. */ /** * RateLimit allows users to query their rate-limit status */ var RateLimit = function (_Requestable) { _inherits(RateLimit, _Requestable); /** * construct a RateLimit * @param {Requestable.auth} auth - the credentials to authenticate to GitHub * @param {string} [apiBase] - the base Github API URL * @return {Promise} - the promise for the http request */ function RateLimit(auth, apiBase) { _classCallCheck(this, RateLimit); return _possibleConstructorReturn(this, (RateLimit.__proto__ || Object.getPrototypeOf(RateLimit)).call(this, auth, apiBase)); } /** * Query the current rate limit * @see https://developer.github.com/v3/rate_limit/ * @param {Requestable.callback} [cb] - will receive the rate-limit data * @return {Promise} - the promise for the http request */ _createClass(RateLimit, [{ key: 'getRateLimit', value: function getRateLimit(cb) { return this._request('GET', '/rate_limit', null, cb); } }]); return RateLimit; }(_Requestable3.default); 
 
 module.exports = RateLimit;
 
 
